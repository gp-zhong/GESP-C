<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>广度优先搜索</title>
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            light: '#93c5fd',
                            DEFAULT: '#3b82f6',
                            dark: '#2563eb',
                        },
                        secondary: {
                            light: '#c7d2fe',
                            DEFAULT: '#818cf8',
                            dark: '#6366f1',
                        },
                        codeBlock: '#1e293b',
                    },
                    fontFamily: {
                        sans: ['Poppins', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        .card-hover {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card-hover:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(59, 130, 246, 0.1), 0 10px 10px -5px rgba(59, 130, 246, 0.04);
        }
        .code-block::-webkit-scrollbar {
            height: 8px;
        }
        .code-block::-webkit-scrollbar-thumb {
            background-color: #3b82f6;
            border-radius: 4px;
        }
        .code-block::-webkit-scrollbar-track {
            background-color: #e2e8f0;
            border-radius: 4px;
        }
        
        /* 保留原有自定义样式 */
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
        }
        .bg-primary { background-color: var(--primary); }
        .bg-primary-dark { background-color: var(--primary-dark); }
        .bg-primary-light { background-color: var(--primary-light); }
        .text-primary { color: var(--primary); }
        .text-primary-dark { color: var(--primary-dark); }
        .text-primary-light { color: var(--primary-light); }
        .hover\:bg-primary-dark:hover { background-color: var(--primary-dark); }
        .border-primary { border-color: var(--primary); }
        
        .bg-codeBlock {
            background-color: #1e293b;
        }
        
        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="min-h-screen max-w-6xl mx-auto px-8 py-10">
        <!-- Header -->
        <header class="mb-12 text-center">
            <div class="inline-block px-3 py-1 bg-primary-light text-primary-dark rounded-full text-sm font-medium mb-4">
                图论算法
            </div>
            <h1 class="text-4xl font-bold text-gray-800 mb-4">广度优先搜索</h1>
            <p class="text-lg text-gray-600 max-w-3xl mx-auto">一种用于遍历或搜索树或图数据结构的算法，逐层访问节点，先访问所有邻居节点再访问下一层</p>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 算法基础 Section -->
            <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                <div class="flex items-center mb-6">
                    <i class="fas fa-cogs text-primary text-xl mr-3"></i>
                    <h2 class="text-2xl font-bold text-gray-800">算法基础</h2>
                </div>
                <div class="space-y-4 text-gray-700">
                    <p>广度优先搜索（Breadth-First Search，简称BFS）是一种用于遍历或搜索树或图的算法。它从起始节点开始，逐层访问所有相邻节点，确保按距离递增的顺序访问所有节点。</p>
                    
                    <!-- 算法原理 Section -->
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">算法原理</h3>
                    <p>BFS算法使用一个队列来存储待访问的节点。它从起始节点开始，逐层访问所有相邻节点，确保按距离递增的顺序访问所有节点。</p>
                    
                    <!-- 代码实现 Section -->
                    <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                        <div class="flex items-center mb-6">
                            <i class="fas fa-code text-primary text-xl mr-3"></i>
                            <h2 class="text-2xl font-bold text-gray-800">代码实现</h2>
                        </div>
                        <div class="space-y-4 text-gray-700">
                            <h3 class="text-xl font-semibold text-gray-800 mb-3">使用队列实现</h3>
                            <div class="mb-4">
                                <button class="code-toggle-btn px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg transition duration-300 flex items-center" data-target="queue-code">
                                    <i class="fas fa-code mr-2"></i> <span>展开/收起代码</span>
                                </button>
                            </div>
                            <div id="queue-code" class="overflow-x-auto bg-codeBlock rounded-lg p-4 mb-4 code-block">
                                <pre class="text-gray-100 font-mono text-sm"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

class Graph {
private:
    int V;                      // 图中顶点的数量
    std::vector&lt;std::vector&lt;int&gt;&gt; adj;  // 邻接表表示图
    
public:
    // 构造函数
    Graph(int v) : V(v) {
        adj.resize(v);
    }
    
    // 添加边的函数
    void addEdge(int v, int w) {
        adj[v].push_back(w);    // 添加边 v -> w
    }
    
    // 广度优先搜索
    void BFS(int start) {
        // 创建访问标记数组
        std::vector&lt;bool&gt; visited(V, false);
        
        // 创建一个队列用于BFS
        std::queue&lt;int&gt; queue;
        
        // 标记起始顶点为已访问
        visited[start] = true;
        queue.push(start);  // 将起始顶点加入队列
        
        std::cout << "广度优先遍历（从顶点" << start << "开始）: ";
        
        // 当队列不为空时
        while (!queue.empty()) {
            // 从队列中取出一个顶点
            int v = queue.front();
            queue.pop();
            std::cout << v << " ";
            
            // 遍历与当前顶点相邻的所有顶点
            for (int i : adj[v]) {
                // 如果顶点未被访问，则标记为已访问并加入队列
                if (!visited[i]) {
                    visited[i] = true;
                    queue.push(i);
                }
            }
        }
        
        std::cout << std::endl;
        
        // 处理图中非连通的部分
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                // 对未访问的顶点，使用BFS遍历
                visited[i] = true;
                queue.push(i);
                
                while (!queue.empty()) {
                    int v = queue.front();
                    queue.pop();
                    std::cout << v << " ";
                    
                    for (int j : adj[v]) {
                        if (!visited[j]) {
                            visited[j] = true;
                            queue.push(j);
                        }
                    }
                }
            }
        }
    }
};

int main() {
    // 创建一个有4个顶点的图
    Graph g(4);
    
    // 添加边
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);
    
    // 从顶点2开始执行BFS
    g.BFS(2);
    
    return 0;
}</code></pre>
                            </div>
                            
                            <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r mb-4">
                                <div class="flex items-start">
                                    <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-3"></i>
                                    <p class="text-gray-700">
                                        <strong>队列特性</strong>：BFS利用队列的先进先出（FIFO）特性，保证了按照离起始点距离的递增顺序访问节点。这一特性使得BFS非常适合寻找无权图中的最短路径。
                                    </p>
                                </div>
                            </div>
                        </div>
                    </section>
                </div>
            </section>
            
            <!-- 算法分析 Section -->
            <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                <div class="flex items-center mb-6">
                    <i class="fas fa-chart-line text-primary text-xl mr-3"></i>
                    <h2 class="text-2xl font-bold text-gray-800">算法分析</h2>
                </div>
                <div class="space-y-4 text-gray-700">
                    <h3 class="text-xl font-semibold text-gray-800 mb-3">时间复杂度</h3>
                    <div class="p-5 bg-gray-50 rounded-xl">
                        <table class="min-w-full">
                            <thead>
                                <tr class="border-b border-gray-200">
                                    <th class="py-2 text-left">数据结构</th>
                                    <th class="py-2 text-left">时间复杂度</th>
                                    <th class="py-2 text-left">说明</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="border-b border-gray-200">
                                    <td class="py-2">邻接矩阵</td>
                                    <td class="py-2 font-mono">O(V²)</td>
                                    <td class="py-2">V是图中的顶点数，需要检查每个顶点与所有其他顶点的连接</td>
                                </tr>
                                <tr class="border-b border-gray-200">
                                    <td class="py-2">邻接表</td>
                                    <td class="py-2 font-mono">O(V+E)</td>
                                    <td class="py-2">V是顶点数，E是边数，每个顶点和每条边都只会被访问一次</td>
                                </tr>
                                <tr>
                                    <td class="py-2">树</td>
                                    <td class="py-2 font-mono">O(N)</td>
                                    <td class="py-2">N是树中的节点数，每个节点只会被访问一次</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">空间复杂度</h3>
                    <p>广度优先搜索的空间复杂度取决于以下因素：</p>
                    <ul class="list-disc list-inside pl-4 mb-3">
                        <li>邻接矩阵或邻接表存储图的结构，需要 O(V²) 或 O(V+E) 的空间</li>
                        <li>队列存储等待访问的节点，在最坏情况下需要 O(V) 的空间</li>
                        <li>访问标记数组，需要 O(V) 的空间</li>
                        <li>距离数组和前驱节点数组（如果需要记录路径），各需要 O(V) 的空间</li>
                    </ul>
                    <p>因此，总体空间复杂度为 O(V+E) 或 O(V²)，取决于图的表示方式。</p>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">BFS与DFS比较</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full">
                            <thead>
                                <tr class="bg-gray-100">
                                    <th class="py-3 px-4 text-left border-b border-gray-200">特性</th>
                                    <th class="py-3 px-4 text-left border-b border-gray-200">广度优先搜索 (BFS)</th>
                                    <th class="py-3 px-4 text-left border-b border-gray-200">深度优先搜索 (DFS)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="border-b border-gray-200">
                                    <td class="py-3 px-4 font-medium">数据结构</td>
                                    <td class="py-3 px-4">队列（FIFO）</td>
                                    <td class="py-3 px-4">栈（LIFO）或递归</td>
                                </tr>
                                <tr class="border-b border-gray-200">
                                    <td class="py-3 px-4 font-medium">空间复杂度</td>
                                    <td class="py-3 px-4">较高，需要存储整个宽度的节点</td>
                                    <td class="py-3 px-4">较低，只需存储一条路径上的节点</td>
                                </tr>
                                <tr class="border-b border-gray-200">
                                    <td class="py-3 px-4 font-medium">适用场景</td>
                                    <td class="py-3 px-4">最短路径、层次遍历</td>
                                    <td class="py-3 px-4">拓扑排序、连通性分析</td>
                                </tr>
                                <tr class="border-b border-gray-200">
                                    <td class="py-3 px-4 font-medium">搜索顺序</td>
                                    <td class="py-3 px-4">距离起点近的节点先访问</td>
                                    <td class="py-3 px-4">沿着一条路径尽可能深入</td>
                                </tr>
                                <tr class="border-b border-gray-200">
                                    <td class="py-3 px-4 font-medium">完整性</td>
                                    <td class="py-3 px-4">总是找到最短解（无权图）</td>
                                    <td class="py-3 px-4">不保证找到最短解</td>
                                </tr>
                                <tr>
                                    <td class="py-3 px-4 font-medium">实现难度</td>
                                    <td class="py-3 px-4">相对简单</td>
                                    <td class="py-3 px-4">递归版较简单，迭代版略复杂</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">优缺点</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                        <div class="card-hover p-6 bg-gray-50 rounded-xl">
                            <h4 class="text-lg font-semibold text-gray-800 mb-3">
                                <i class="fas fa-check-circle text-green-600 mr-2"></i>
                                优点
                            </h4>
                            <ul class="list-disc list-inside space-y-1">
                                <li>保证找到最短路径（无权图）</li>
                                <li>适合寻找最近的节点</li>
                                <li>适合层次遍历</li>
                                <li>不会陷入无限递归</li>
                                <li>更适合搜索较宽而浅的空间</li>
                            </ul>
                        </div>
                        
                        <div class="card-hover p-6 bg-gray-50 rounded-xl">
                            <h4 class="text-lg font-semibold text-gray-800 mb-3">
                                <i class="fas fa-times-circle text-red-600 mr-2"></i>
                                缺点
                            </h4>
                            <ul class="list-disc list-inside space-y-1">
                                <li>空间复杂度高</li>
                                <li>不易找到深层的解</li>
                                <li>不适合搜索所有可能的路径</li>
                                <li>对于很深的图效率较低</li>
                                <li>不保留完整的搜索路径</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">优化策略</h3>
                    <div class="p-5 bg-primary-light bg-opacity-10 rounded-lg">
                        <ol class="list-decimal list-inside space-y-2 pl-2">
                            <li><strong>双向BFS</strong>：同时从起点和终点开始BFS，当两个搜索相遇时即找到最短路径</li>
                            <li><strong>启发式BFS</strong>：结合启发函数指导搜索方向，类似A*算法的思想</li>
                            <li><strong>多源BFS</strong>：同时从多个源点开始BFS，适用于多源最短路径问题</li>
                            <li><strong>优先队列BFS</strong>：使用优先队列代替普通队列，可以处理带权图的最短路径问题</li>
                            <li><strong>限制搜索空间</strong>：通过剪枝等技术限制搜索空间，减少不必要的节点访问</li>
                        </ol>
                    </div>
                </div>
            </section>
            
            <!-- 应用示例 Section -->
            <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                <div class="flex items-center mb-6">
                    <i class="fas fa-laptop-code text-primary text-xl mr-3"></i>
                    <h2 class="text-2xl font-bold text-gray-800">应用示例</h2>
                </div>
                <div class="space-y-4 text-gray-700">
                    <h3 class="text-xl font-semibold text-gray-800 mb-3">实例：最短路径查找</h3>
                    <div class="mb-4">
                        <button class="code-toggle-btn px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg transition duration-300 flex items-center" data-target="shortest-path-code">
                            <i class="fas fa-code mr-2"></i> <span>展开/收起代码</span>
                        </button>
                    </div>
                    <div id="shortest-path-code" class="overflow-x-auto bg-codeBlock rounded-lg p-4 mb-6 code-block">
                        <pre class="text-gray-100 font-mono text-sm"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

class Graph {
private:
    int V;                      // 图中顶点的数量
    std::vector&lt;std::vector&lt;int&gt;&gt; adj;  // 邻接表表示图
    
public:
    // 构造函数
    Graph(int v) : V(v) {
        adj.resize(v);
    }
    
    // 添加边的函数 (无向图)
    void addEdge(int v, int w) {
        adj[v].push_back(w);    // 添加边 v -> w
        adj[w].push_back(v);    // 添加边 w -> v
    }
    
    // 使用BFS查找最短路径
    void shortestPath(int start, int end) {
        // 访问标记
        std::vector&lt;bool&gt; visited(V, false);
        
        // 存储前驱节点，用于重建路径
        std::vector&lt;int&gt; prev(V, -1);
        
        // 存储从起点到每个节点的距离
        std::vector&lt;int&gt; distance(V, -1);
        
        // 队列
        std::queue&lt;int&gt; queue;
        
        // 初始化起点
        visited[start] = true;
        distance[start] = 0;
        queue.push(start);
        
        // BFS
        while (!queue.empty()) {
            int v = queue.front();
            queue.pop();
            
            // 如果找到终点，终止BFS
            if (v == end) break;
            
            // 遍历邻接点
            for (int u : adj[v]) {
                if (!visited[u]) {
                    visited[u] = true;
                    distance[u] = distance[v] + 1;
                    prev[u] = v;
                    queue.push(u);
                }
            }
        }
        
        // 如果终点不可达
        if (prev[end] == -1) {
            std::cout << "从顶点 " << start << " 无法到达顶点 " << end << std::endl;
            return;
        }
        
        // 计算最短路径
        std::cout << "从顶点 " << start << " 到顶点 " << end << " 的最短路径长度为: " 
                  << distance[end] << std::endl;
        
        // 重建路径
        std::vector&lt;int&gt; path;
        for (int v = end; v != -1; v = prev[v]) {
            path.push_back(v);
        }
        
        // 打印路径
        std::cout << "路径: ";
        for (int i = path.size() - 1; i >= 0; i--) {
            std::cout << path[i];
            if (i > 0) std::cout << " -> ";
        }
        std::cout << std::endl;
    }
};

int main() {
    // 创建一个无向图
    Graph g(8);
    
    // 添加边
    g.addEdge(0, 1);
    g.addEdge(0, 3);
    g.addEdge(1, 2);
    g.addEdge(3, 4);
    g.addEdge(3, 7);
    g.addEdge(4, 5);
    g.addEdge(4, 6);
    g.addEdge(4, 7);
    g.addEdge(5, 6);
    g.addEdge(6, 7);
    
    // 查找从顶点0到顶点6的最短路径
    g.shortestPath(0, 6);
    
    return 0;
}</code></pre>
                    </div>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">实例：二分图检测</h3>
                    <div class="mb-4">
                        <button class="code-toggle-btn px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg transition duration-300 flex items-center" data-target="bipartite-code">
                            <i class="fas fa-code mr-2"></i> <span>展开/收起代码</span>
                        </button>
                    </div>
                    <div id="bipartite-code" class="overflow-x-auto bg-codeBlock rounded-lg p-4 mb-4 code-block">
                        <pre class="text-gray-100 font-mono text-sm"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

class Graph {
private:
    int V;                      // 图中顶点的数量
    std::vector&lt;std::vector&lt;int&gt;&gt; adj;  // 邻接表表示图
    
public:
    // 构造函数
    Graph(int v) : V(v) {
        adj.resize(v);
    }
    
    // 添加边的函数 (无向图)
    void addEdge(int v, int w) {
        adj[v].push_back(w);    // 添加边 v -> w
        adj[w].push_back(v);    // 添加边 w -> v
    }
    
    // 使用BFS检查图是否为二分图
    bool isBipartite() {
        // 颜色数组，-1表示未着色，0和1表示两种不同颜色
        std::vector&lt;int&gt; color(V, -1);
        
        // 对图中的每个连通分量进行检查
        for (int start = 0; start < V; start++) {
            if (color[start] == -1) {
                // 如果该连通分量不是二分图，则整个图不是二分图
                if (!isBipartiteUtil(start, color))
                    return false;
            }
        }
        
        // 所有连通分量都是二分图
        return true;
    }
    
private:
    // 检查从start开始的连通分量是否为二分图
    bool isBipartiteUtil(int start, std::vector&lt;int&gt;& color) {
        // 队列
        std::queue&lt;int&gt; queue;
        
        // 初始化起点
        color[start] = 0;  // 将起点着色为0
        queue.push(start);
        
        // BFS
        while (!queue.empty()) {
            int v = queue.front();
            queue.pop();
            
            // 遍历邻接点
            for (int u : adj[v]) {
                // 如果邻接点未着色
                if (color[u] == -1) {
                    // 给邻接点着相反的颜色
                    color[u] = 1 - color[v];
                    queue.push(u);
                }
                // 如果邻接点已着色且颜色与当前顶点相同，则不是二分图
                else if (color[u] == color[v]) {
                    return false;
                }
            }
        }
        
        return true;
    }
};

int main() {
    // 创建一个无向图
    Graph g1(4);
    
    // 添加边，这是一个二分图
    g1.addEdge(0, 1);
    g1.addEdge(0, 3);
    g1.addEdge(1, 2);
    g1.addEdge(2, 3);
    
    if (g1.isBipartite())
        std::cout << "图1是二分图" << std::endl;
    else
        std::cout << "图1不是二分图" << std::endl;
    
    // 创建另一个无向图
    Graph g2(3);
    
    // 添加边，这不是一个二分图（有奇数环）
    g2.addEdge(0, 1);
    g2.addEdge(1, 2);
    g2.addEdge(2, 0);
    
    if (g2.isBipartite())
        std::cout << "图2是二分图" << std::endl;
    else
        std::cout << "图2不是二分图" << std::endl;
    
    return 0;
}</code></pre>
                    </div>
                    
                    <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r mb-4">
                        <div class="flex items-start">
                            <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-3"></i>
                            <p class="text-gray-700">
                                <strong>算法对比</strong>：虽然DFS和BFS都可以用于寻找路径，但BFS因为其层级遍历的特性，特别适合寻找无权图中的最短路径和检测二分图。
                            </p>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- 交互式可视化 -->
            <section id="visualization" class="mb-16">
                <h2 class="text-3xl font-bold mb-6 text-gray-800 border-l-4 border-primary pl-3">交互式可视化</h2>
                <p class="mb-4">
                    广度优先搜索（BFS）是一种图搜索算法，它从根节点开始，沿着图的宽度遍历所有节点。对于每一层节点，BFS 会先访问所有邻接节点，然后再移动到下一层。
                </p>
                <p class="mb-6">
                    下面是广度优先搜索算法的交互式可视化演示。您可以通过点击节点创建图，然后选择起始节点观察BFS遍历的过程。已为您初始化一个示例图，可直接点击"开始BFS"按钮并选择一个起始节点体验算法运行过程。
                </p>
                
                <div class="flex flex-col items-center p-6 bg-gray-50 rounded-xl">
                    <!-- 图可视化区域 -->
                    <div id="graph-container" class="w-full h-96 bg-blue-100 rounded-lg shadow-inner p-4 mb-6 flex items-center justify-center">
                        <canvas id="graph-canvas" class="w-full h-full"></canvas>
                    </div>
                    
                    <!-- 控制区域 - 将按钮和操作说明分为两列 -->
                    <div class="w-full grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                        <!-- 左侧：控制按钮和速度滑块 -->
                        <div class="flex flex-col space-y-6">
                            <div class="flex flex-wrap gap-4">
                                <button id="add-node" class="px-4 py-2 bg-primary hover:bg-primary-dark text-white rounded-lg transition duration-300 flex items-center">
                                    <i class="fas fa-plus mr-2"></i> 添加节点
                                </button>
                                <button id="add-edge" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition duration-300 flex items-center">
                                    <i class="fas fa-link mr-2"></i> 添加边
                                </button>
                                <button id="start-bfs" class="px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded-lg transition duration-300 flex items-center">
                                    <i class="fas fa-play mr-2"></i> 开始BFS
                                </button>
                                <button id="reset" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg transition duration-300 flex items-center">
                                    <i class="fas fa-undo mr-2"></i> 重置
                                </button>
                            </div>
                            <div class="w-full flex items-center">
                                <span class="mr-3 text-sm font-medium text-gray-700">速度:</span>
                                <input id="speed-slider" type="range" min="1" max="5" value="3" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span class="ml-3 text-sm font-medium text-gray-700" id="speed-value">中等</span>
                            </div>
                        </div>
                        
                        <!-- 右侧：操作说明 -->
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <h4 class="font-semibold text-gray-800 mb-2">操作说明:</h4>
                            <ul class="list-disc list-inside text-sm text-gray-600 pl-2">
                                <li>已为您初始化一个演示图，您可以直接体验或者自行创建新图</li>
                                <li>点击"添加节点"按钮后，在画布上点击创建新节点</li>
                                <li>点击"添加边"按钮后，先点击起始节点再点击目标节点创建边</li>
                                <li>点击"开始BFS"按钮后，点击一个节点作为BFS的起点</li>
                                <li>使用速度滑块控制动画速度</li>
                                <li>点击"重置"按钮清除所有节点和边并重新初始化示例图</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <h3 class="text-xl font-semibold text-gray-800 mt-8 mb-4">BFS遍历过程</h3>
                <div class="overflow-x-auto">
                    <div id="bfs-output" class="w-full bg-gray-100 p-4 rounded-lg font-mono text-sm h-32 overflow-y-auto">
                        BFS遍历结果将显示在这里...
                    </div>
                </div>
                
                <!-- JavaScript 实现可视化 -->
                <script>
                    // 节点和边的颜色定义
                    const COLORS = {
                        NODE: {
                            DEFAULT: '#3b82f6',
                            SELECTED: '#f59e0b',
                            VISITED: '#10b981',
                            CURRENT: '#ef4444',
                            TEXT: '#ffffff'
                        },
                        EDGE: {
                            DEFAULT: '#64748b',
                            TRAVERSED: '#10b981'
                        }
                    };
                    
                    // 图的数据结构
                    class Graph {
                        constructor() {
                            this.nodes = [];
                            this.edges = [];
                            this.adjacencyList = {};
                        }
                        
                        // 添加节点
                        addNode(x, y, label) {
                            const node = { x, y, label, color: COLORS.NODE.DEFAULT };
                            this.nodes.push(node);
                            this.adjacencyList[label] = [];
                            return node;
                        }
                        
                        // 添加边
                        addEdge(startLabel, endLabel) {
                            const startNode = this.getNodeByLabel(startLabel);
                            const endNode = this.getNodeByLabel(endLabel);
                            
                            if (startNode && endNode) {
                                this.edges.push({
                                    start: startNode,
                                    end: endNode,
                                    color: COLORS.EDGE.DEFAULT
                                });
                                
                                // 更新邻接表（无向图）
                                this.adjacencyList[startLabel].push(endLabel);
                                this.adjacencyList[endLabel].push(startLabel);
                            }
                        }
                        
                        // 通过标签获取节点
                        getNodeByLabel(label) {
                            return this.nodes.find(node => node.label === label);
                        }
                        
                        // 通过坐标获取节点
                        getNodeByPosition(x, y) {
                            const radius = 24;
                            return this.nodes.find(node => {
                                const distance = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
                                return distance <= radius;
                            });
                        }
                        
                        // 重置所有节点和边的颜色
                        resetColors() {
                            this.nodes.forEach(node => {
                                node.color = COLORS.NODE.DEFAULT;
                            });
                            
                            this.edges.forEach(edge => {
                                edge.color = COLORS.EDGE.DEFAULT;
                            });
                        }
                    }
                    
                    // 画布管理器
                    class CanvasManager {
                        constructor(canvasId) {
                            this.canvas = document.getElementById(canvasId);
                            this.ctx = this.canvas.getContext('2d');
                            this.nodeRadius = 24;
                            this.resizeCanvas();
                            
                            // 添加窗口大小调整事件监听
                            window.addEventListener('resize', () => this.resizeCanvas());
                        }
                        
                        // 调整画布大小
                        resizeCanvas() {
                            const container = this.canvas.parentElement;
                            this.canvas.width = container.clientWidth;
                            this.canvas.height = container.clientHeight;
                        }
                        
                        // 清空画布
                        clear() {
                            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        }
                        
                        // 绘制节点
                        drawNode(node) {
                            const { x, y, label, color } = node;
                            
                            // 绘制节点阴影
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, this.nodeRadius + 2, 0, Math.PI * 2);
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                            this.ctx.fill();
                            
                            // 绘制圆形
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, this.nodeRadius, 0, Math.PI * 2);
                            this.ctx.fillStyle = color;
                            this.ctx.fill();
                            
                            // 绘制边框
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, this.nodeRadius, 0, Math.PI * 2);
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 2;
                            this.ctx.stroke();
                            
                            // 绘制标签
                            this.ctx.fillStyle = COLORS.NODE.TEXT;
                            this.ctx.font = 'bold 16px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText(label, x, y);
                        }
                        
                        // 绘制边
                        drawEdge(edge) {
                            const { start, end, color } = edge;
                            
                            // 设置虚线样式
                            this.ctx.setLineDash([]);
                            
                            // 计算方向向量
                            const dx = end.x - start.x;
                            const dy = end.y - start.y;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            
                            // 归一化方向向量
                            const nx = dx / length;
                            const ny = dy / length;
                            
                            // 计算线段起点和终点（考虑节点半径）
                            const startX = start.x + nx * this.nodeRadius;
                            const startY = start.y + ny * this.nodeRadius;
                            const endX = end.x - nx * this.nodeRadius;
                            const endY = end.y - ny * this.nodeRadius;
                            
                            // 绘制线段
                            this.ctx.beginPath();
                            this.ctx.moveTo(startX, startY);
                            this.ctx.lineTo(endX, endY);
                            this.ctx.strokeStyle = color;
                            this.ctx.lineWidth = 3;
                            this.ctx.stroke();
                            
                            // 绘制箭头（无向图不需要）
                            // this.drawArrow(endX, endY, nx, ny, color);
                        }
                        
                        // 绘制整个图
                        drawGraph(graph) {
                            this.clear();
                            
                            // 先绘制所有边
                            graph.edges.forEach(edge => {
                                this.drawEdge(edge);
                            });
                            
                            // 再绘制所有节点
                            graph.nodes.forEach(node => {
                                this.drawNode(node);
                            });
                        }
                    }
                    
                    // BFS算法
                    class BFSAlgorithm {
                        constructor(graph) {
                            this.graph = graph;
                            this.queue = [];
                            this.visited = new Set();
                            this.traversalOrder = [];
                            this.edges = [];
                        }
                        
                        // 初始化BFS
                        initialize(startLabel) {
                            this.queue = [startLabel];
                            this.visited = new Set([startLabel]);
                            this.traversalOrder = [startLabel];
                            this.edges = [];
                        }
                        
                        // 执行单步BFS
                        step() {
                            if (this.queue.length === 0) {
                                return { done: true };
                            }
                            
                            const currentLabel = this.queue.shift();
                            const neighbors = this.graph.adjacencyList[currentLabel] || [];
                            
                            // 检查每个邻居
                            for (const neighbor of neighbors) {
                                if (!this.visited.has(neighbor)) {
                                    this.visited.add(neighbor);
                                    this.queue.push(neighbor);
                                    this.traversalOrder.push(neighbor);
                                    this.edges.push({ from: currentLabel, to: neighbor });
                                    
                                    return {
                                        done: false,
                                        current: currentLabel,
                                        neighbor: neighbor,
                                        queue: [...this.queue] // 当前队列的副本
                                    };
                                }
                            }
                            
                            // 如果当前节点处理完所有邻居但没有新的邻居被添加到队列
                            return {
                                done: false,
                                current: currentLabel,
                                queue: [...this.queue]
                            };
                        }
                    }
                    
                    // 初始化画布和图
                    document.addEventListener('DOMContentLoaded', function() {
                        const canvas = new CanvasManager('graph-canvas');
                        const graph = new Graph();
                        let nextNodeLabel = 1;
                        let mode = 'none';
                        let selectedNode = null;
                        let animationDelay = 500; // 默认动画延迟（毫秒）
                        let bfsAlgorithm = null;
                        let animationInProgress = false;
                        
                        // 获取DOM元素
                        const addNodeBtn = document.getElementById('add-node');
                        const addEdgeBtn = document.getElementById('add-edge');
                        const startBfsBtn = document.getElementById('start-bfs');
                        const resetBtn = document.getElementById('reset');
                        const speedSlider = document.getElementById('speed-slider');
                        const speedValue = document.getElementById('speed-value');
                        const bfsOutput = document.getElementById('bfs-output');
                        
                        // 设置按钮点击事件
                        addNodeBtn.addEventListener('click', () => {
                            setMode('add-node');
                        });
                        
                        addEdgeBtn.addEventListener('click', () => {
                            setMode('add-edge');
                        });
                        
                        startBfsBtn.addEventListener('click', () => {
                            if (graph.nodes.length === 0) {
                                alert('请先添加节点');
                                return;
                            }
                            setMode('start-bfs');
                        });
                        
                        resetBtn.addEventListener('click', () => {
                            resetGraph();
                        });
                        
                        // 速度滑块事件
                        speedSlider.addEventListener('input', function() {
                            const speed = parseInt(this.value);
                            // 更新延迟时间和显示文本
                            switch (speed) {
                                case 1:
                                    animationDelay = 1200;
                                    speedValue.textContent = '非常慢';
                                    break;
                                case 2:
                                    animationDelay = 800;
                                    speedValue.textContent = '慢';
                                    break;
                                case 3:
                                    animationDelay = 500;
                                    speedValue.textContent = '中等';
                                    break;
                                case 4:
                                    animationDelay = 300;
                                    speedValue.textContent = '快';
                                    break;
                                case 5:
                                    animationDelay = 100;
                                    speedValue.textContent = '非常快';
                                    break;
                            }
                        });
                        
                        // 设置模式
                        function setMode(newMode) {
                            // 如果动画正在进行，不允许切换模式
                            if (animationInProgress && newMode !== 'none') {
                                return;
                            }
                            
                            // 重置选择的节点
                            if (selectedNode) {
                                selectedNode.color = COLORS.NODE.DEFAULT;
                                selectedNode = null;
                            }
                            
                            // 更新模式
                            mode = newMode;
                            
                            // 重置按钮样式
                            [addNodeBtn, addEdgeBtn, startBfsBtn].forEach(btn => {
                                btn.classList.remove('ring-2', 'ring-offset-2');
                            });
                            
                            // 根据模式设置相应按钮样式
                            switch (mode) {
                                case 'add-node':
                                    addNodeBtn.classList.add('ring-2', 'ring-offset-2');
                                    canvas.canvas.style.cursor = 'crosshair';
                                    break;
                                case 'add-edge':
                                    addEdgeBtn.classList.add('ring-2', 'ring-offset-2');
                                    canvas.canvas.style.cursor = 'pointer';
                                    break;
                                case 'start-bfs':
                                    startBfsBtn.classList.add('ring-2', 'ring-offset-2');
                                    canvas.canvas.style.cursor = 'pointer';
                                    break;
                                default:
                                    canvas.canvas.style.cursor = 'default';
                            }
                            
                            // 重绘画布
                            canvas.drawGraph(graph);
                        }
                        
                        // 创建示例图
                        function createExampleGraph() {
                            // 添加节点（在画布上均匀分布）
                            const width = canvas.canvas.width;
                            const height = canvas.canvas.height;
                            
                            const node1 = graph.addNode(width * 0.2, height * 0.3, nextNodeLabel++);
                            const node2 = graph.addNode(width * 0.5, height * 0.2, nextNodeLabel++);
                            const node3 = graph.addNode(width * 0.8, height * 0.3, nextNodeLabel++);
                            const node4 = graph.addNode(width * 0.1, height * 0.6, nextNodeLabel++);
                            const node5 = graph.addNode(width * 0.4, height * 0.7, nextNodeLabel++);
                            const node6 = graph.addNode(width * 0.7, height * 0.6, nextNodeLabel++);
                            const node7 = graph.addNode(width * 0.5, height * 0.5, nextNodeLabel++);
                            
                            // 添加边
                            graph.addEdge(1, 2);
                            graph.addEdge(1, 4);
                            graph.addEdge(2, 3);
                            graph.addEdge(2, 7);
                            graph.addEdge(3, 6);
                            graph.addEdge(4, 5);
                            graph.addEdge(5, 7);
                            graph.addEdge(6, 7);
                            
                            // 绘制图
                            canvas.drawGraph(graph);
                            
                            // 显示初始信息
                            bfsOutput.innerHTML = `<span class="text-gray-700">初始化完成，请选择一个起始节点开始BFS遍历，或自行修改图结构。</span>`;
                        }
                        
                        // 重置图
                        function resetGraph() {
                            // 如果动画正在进行，不允许重置
                            if (animationInProgress) {
                                return;
                            }
                            
                            // 清空图数据
                            graph.nodes = [];
                            graph.edges = [];
                            graph.adjacencyList = {};
                            
                            // 重置节点计数器
                            nextNodeLabel = 1;
                            
                            // 重置模式
                            setMode('none');
                            
                            // 创建新的示例图
                            createExampleGraph();
                        }
                        
                        // 运行BFS动画
                        async function runBFSAnimation(startNode) {
                            // 设置动画状态
                            animationInProgress = true;
                            setMode('none');
                            
                            // 重置颜色
                            graph.resetColors();
                            
                            // 初始化BFS算法
                            bfsAlgorithm = new BFSAlgorithm(graph);
                            bfsAlgorithm.initialize(startNode.label);
                            
                            // 标记起始节点
                            startNode.color = COLORS.NODE.CURRENT;
                            canvas.drawGraph(graph);
                            
                            // 清空输出区域
                            bfsOutput.innerHTML = '';
                            bfsOutput.innerHTML += `<div class="mb-2"><span class="font-semibold">开始BFS遍历，起点:</span> 节点 ${startNode.label}</div>`;
                            bfsOutput.innerHTML += `<div class="mb-2"><span class="font-semibold">初始队列:</span> [${startNode.label}]</div>`;
                            
                            // 延迟函数
                            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
                            
                            // 执行BFS动画
                            let result;
                            let step = 1;
                            
                            do {
                                await delay(animationDelay);
                                result = bfsAlgorithm.step();
                                
                                if (!result.done) {
                                    if (result.neighbor) {
                                        // 获取当前节点和邻居节点
                                        const currentNode = graph.getNodeByLabel(result.current);
                                        const neighborNode = graph.getNodeByLabel(result.neighbor);
                                        
                                        // 更新节点颜色
                                        currentNode.color = COLORS.NODE.VISITED;
                                        neighborNode.color = COLORS.NODE.CURRENT;
                                        
                                        // 更新边的颜色
                                        for (const edge of graph.edges) {
                                            if ((edge.start === currentNode && edge.end === neighborNode) || 
                                                (edge.start === neighborNode && edge.end === currentNode)) {
                                                edge.color = COLORS.EDGE.TRAVERSED;
                                                break;
                                            }
                                        }
                                        
                                        // 绘制更新后的图
                                        canvas.drawGraph(graph);
                                        
                                        // 更新输出信息
                                        const queueStr = result.queue.join(' → ') || '空';
                                        bfsOutput.innerHTML += `<div class="mb-1"><span class="font-semibold">步骤 ${step}:</span> 从节点 ${result.current} 访问节点 ${result.neighbor}，当前队列: [${queueStr}]</div>`;
                                        step++;
                                        
                                    } else {
                                        // 当前节点处理完毕但没有新的邻居
                                        const currentNode = graph.getNodeByLabel(result.current);
                                        currentNode.color = COLORS.NODE.VISITED;
                                        canvas.drawGraph(graph);
                                        
                                        // 更新输出信息
                                        const queueStr = result.queue.join(' → ') || '空';
                                        bfsOutput.innerHTML += `<div class="mb-1"><span class="font-semibold">处理完毕:</span> 节点 ${result.current} 的所有邻居已访问，当前队列: [${queueStr}]</div>`;
                                    }
                                    
                                    // 滚动到底部
                                    bfsOutput.scrollTop = bfsOutput.scrollHeight;
                                }
                            } while (!result.done);
                            
                            // BFS完成
                            bfsOutput.innerHTML += `<div class="mt-2 font-semibold">BFS遍历完成!</div>`;
                            bfsOutput.innerHTML += `<div><span class="font-semibold">遍历顺序:</span> ${bfsAlgorithm.traversalOrder.join(' → ')}</div>`;
                            
                            // 重置动画状态
                            animationInProgress = false;
                        }
                        
                        // 添加画布点击事件
                        canvas.canvas.addEventListener('click', function(e) {
                            // 如果动画正在进行，忽略点击事件
                            if (animationInProgress) {
                                return;
                            }
                            
                            // 获取点击坐标
                            const rect = canvas.canvas.getBoundingClientRect();
                            // Calculate scaled coordinates considering canvas size ratio
                            const scaleX = canvas.canvas.width / rect.width;
                            const scaleY = canvas.canvas.height / rect.height;
                            const x = (e.clientX - rect.left) * scaleX;
                            const y = (e.clientY - rect.top) * scaleY;
                            
                            // 检查是否点击了节点
                            const clickedNode = graph.getNodeByPosition(x, y);
                            
                            switch (mode) {
                                case 'add-node':
                                    // 如果点击位置没有节点，添加一个新节点
                                    if (!clickedNode) {
                                        graph.addNode(x, y, nextNodeLabel++);
                                        canvas.drawGraph(graph);
                                        bfsOutput.innerHTML += `<div class="mb-1">在位置 (${Math.round(x)}, ${Math.round(y)}) 添加了新节点</div>`;
                                    }
                                    break;
                                    
                                case 'add-edge':
                                    // 如果点击了节点
                                    if (clickedNode) {
                                        if (!selectedNode) {
                                            // 选择第一个节点
                                            selectedNode = clickedNode;
                                            selectedNode.color = COLORS.NODE.SELECTED;
                                            canvas.drawGraph(graph);
                                            bfsOutput.innerHTML += `<div class="mb-1">选择了节点 ${clickedNode.label} 作为边的起点</div>`;
                                        } else if (selectedNode !== clickedNode) {
                                            // 选择第二个节点并添加边
                                            graph.addEdge(selectedNode.label, clickedNode.label);
                                            
                                            // 重置选中节点的颜色
                                            selectedNode.color = COLORS.NODE.DEFAULT;
                                            bfsOutput.innerHTML += `<div class="mb-1">添加了从节点 ${selectedNode.label} 到节点 ${clickedNode.label} 的边</div>`;
                                            selectedNode = null;
                                            
                                            // 重绘画布
                                            canvas.drawGraph(graph);
                                        }
                                    }
                                    break;
                                    
                                case 'start-bfs':
                                    // 如果点击了节点，开始BFS
                                    if (clickedNode) {
                                        runBFSAnimation(clickedNode);
                                    }
                                    break;
                            }
                        });
                        
                        // 添加鼠标移动事件以显示交互提示
                        canvas.canvas.addEventListener('mousemove', function(e) {
                            // 如果动画正在进行，忽略鼠标移动事件
                            if (animationInProgress) {
                                return;
                            }
                            
                            // 获取鼠标坐标
                            const rect = canvas.canvas.getBoundingClientRect();
                            // Calculate scaled coordinates considering canvas size ratio
                            const scaleX = canvas.canvas.width / rect.width;
                            const scaleY = canvas.canvas.height / rect.height;
                            const x = (e.clientX - rect.left) * scaleX;
                            const y = (e.clientY - rect.top) * scaleY;
                            
                            // 检查是否悬停在节点上
                            const hoveredNode = graph.getNodeByPosition(x, y);
                            
                            if (hoveredNode) {
                                canvas.canvas.style.cursor = 'pointer';
                            } else if (mode === 'add-node') {
                                canvas.canvas.style.cursor = 'crosshair';
                            } else {
                                canvas.canvas.style.cursor = 'default';
                            }
                        });
                        
                        // 初始化示例图
                        createExampleGraph();
                    });

                    // 代码展开/收起功能
                    document.addEventListener('DOMContentLoaded', function() {
                        // 获取所有的代码切换按钮
                        const codeToggleBtns = document.querySelectorAll('.code-toggle-btn');
                        
                        // 默认先隐藏所有代码块
                        document.querySelectorAll('.code-block').forEach(block => {
                            block.style.display = 'none';
                        });
                        
                        // 为每个按钮添加点击事件
                        codeToggleBtns.forEach(btn => {
                            btn.addEventListener('click', function() {
                                const targetId = this.getAttribute('data-target');
                                const targetBlock = document.getElementById(targetId);
                                
                                if (targetBlock.style.display === 'none') {
                                    targetBlock.style.display = 'block';
                                    this.querySelector('span').textContent = '收起代码';
                                } else {
                                    targetBlock.style.display = 'none';
                                    this.querySelector('span').textContent = '展开代码';
                                }
                            });
                        });
                    });

                    const backToTop = document.getElementById('backToTop');
                    
                    window.addEventListener('scroll', () => {
                        if (window.scrollY > 300) {
                            backToTop.classList.remove('opacity-0', 'invisible');
                            backToTop.classList.add('opacity-100', 'visible');
                        } else {
                            backToTop.classList.remove('opacity-100', 'visible');
                            backToTop.classList.add('opacity-0', 'invisible');
                        }
                    });
                    
                    backToTop.addEventListener('click', () => {
                        window.scrollTo({
                            top: 0,
                            behavior: 'smooth'
                        });
                    });
                </script>
            </section>
        </main>
        <!-- 页脚 -->
        <footer class="mt-16 py-8 border-t border-gray-200">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="mb-4 md:mb-0">
                    <p class="text-sm text-gray-500">图论算法系列 — 搜索算法</p>
                </div>
                <div class="flex space-x-6">
                    <a href="index.html" class="text-gray-500 hover:text-primary transition-colors">
                        <i class="fas fa-home mr-2"></i>首页
                    </a>
                    <a href="深度优先搜索.html" class="text-gray-500 hover:text-primary transition-colors">
                        <i class="fas fa-project-diagram mr-2"></i>深度优先搜索
                    </a>
                </div>
            </div>
        </footer>
    </div>
    
    <!-- Back to Top Button -->
    <button id="backToTop" class="fixed bottom-8 right-8 bg-primary hover:bg-primary-dark text-white p-3 rounded-full shadow-lg transition-all duration-300 ease-in-out opacity-0 invisible z-50">
        <i class="fas fa-arrow-up"></i>
    </button>
    
    <!-- JavaScript for Back to top button -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 获取所有的代码切换按钮
            const codeToggleBtns = document.querySelectorAll('.code-toggle-btn');
            
            // 默认先隐藏所有代码块
            document.querySelectorAll('.code-block').forEach(block => {
                block.style.display = 'none';
            });
            
            // 为每个按钮添加点击事件
            codeToggleBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-target');
                    const targetBlock = document.getElementById(targetId);
                    
                    if (targetBlock.style.display === 'none') {
                        targetBlock.style.display = 'block';
                        this.querySelector('span').textContent = '收起代码';
                    } else {
                        targetBlock.style.display = 'none';
                        this.querySelector('span').textContent = '展开代码';
                    }
                });
            });

            // Back to top button functionality
            const backToTop = document.getElementById('backToTop');
            
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    backToTop.classList.remove('opacity-0', 'invisible');
                    backToTop.classList.add('opacity-100', 'visible');
                } else {
                    backToTop.classList.remove('opacity-100', 'visible');
                    backToTop.classList.add('opacity-0', 'invisible');
                }
            });
            
            backToTop.addEventListener('click', () => {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        });
    </script>
    
    <!-- Simple ScrollReveal effect -->
    <script src="https://unpkg.com/scrollreveal"></script>
    <script>
        ScrollReveal().reveal('section', { 
            delay: 200,
            distance: '20px',
            origin: 'bottom',
            duration: 800,
            easing: 'ease-in-out'
        });
    </script>
</body>
</html>
 