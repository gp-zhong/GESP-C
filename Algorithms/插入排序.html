<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>插入排序</title>
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            light: '#a5f3fc',
                            DEFAULT: '#06b6d4',
                            dark: '#0891b2',
                        },
                        secondary: {
                            light: '#c7d2fe',
                            DEFAULT: '#818cf8',
                            dark: '#6366f1',
                        },
                        codeBlock: '#1e293b',
                    },
                    fontFamily: {
                        sans: ['Poppins', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        .card-hover {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card-hover:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(6, 182, 212, 0.1), 0 10px 10px -5px rgba(6, 182, 212, 0.04);
        }
        .code-block::-webkit-scrollbar {
            height: 8px;
        }
        .code-block::-webkit-scrollbar-thumb {
            background-color: #06b6d4;
            border-radius: 4px;
        }
        .code-block::-webkit-scrollbar-track {
            background-color: #e2e8f0;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="min-h-screen max-w-6xl mx-auto px-8 py-10">
        <!-- Header -->
        <header class="mb-12 text-center">
            <div class="inline-block px-3 py-1 bg-primary-light text-primary-dark rounded-full text-sm font-medium mb-4">
                算法基础
            </div>
            <h1 class="text-4xl font-bold text-gray-800 mb-4">插入排序</h1>
            <p class="text-lg text-gray-600 max-w-3xl mx-auto">一种简单高效的基础排序算法，通过构建有序序列，对未排序数据逐个插入到适当位置</p>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 算法原理 Section -->
            <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                <div class="flex items-center mb-6">
                    <i class="fas fa-info-circle text-primary text-xl mr-3"></i>
                    <h2 class="text-2xl font-bold text-gray-800">算法原理</h2>
                </div>
                <div class="space-y-4 text-gray-700">
                    <p>插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是：</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                        <div class="card-hover p-6 bg-gray-50 rounded-xl">
                            <h3 class="text-lg font-semibold text-gray-800 mb-3">
                                <i class="fas fa-check-circle text-primary-dark mr-2"></i>
                                基本思想
                            </h3>
                            <p>将待排序的元素一个一个插入到已排好序的序列中，直到所有元素都插入完为止。类似于我们打牌时的整理牌的过程。</p>
                        </div>
                        
                        <div class="card-hover p-6 bg-gray-50 rounded-xl">
                            <h3 class="text-lg font-semibold text-gray-800 mb-3">
                                <i class="fas fa-cog text-primary-dark mr-2"></i>
                                核心特点
                            </h3>
                            <ul class="list-disc pl-6 space-y-1">
                                <li>原地排序算法</li>
                                <li>稳定排序算法</li>
                                <li>最好时间复杂度 O(n)</li>
                                <li>平均时间复杂度 O(n²)</li>
                                <li>对小规模数据或基本有序数据非常高效</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="p-5 bg-primary-light bg-opacity-10 rounded-lg">
                        <p>插入排序的优势在于简单易实现，且在处理小规模数据或已经部分有序的数据时效率较高。它比冒泡排序和选择排序更高效，被广泛应用于复杂排序算法的子过程。</p>
                    </div>

                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">排序过程</h3>
                    <ol class="list-decimal list-inside space-y-2 pl-4">
                        <li>从第一个元素开始，该元素可以认为已经被排序</li>
                        <li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
                        <li>如果已排序的元素大于新元素，将该元素移到下一位置</li>
                        <li>重复步骤3，直到找到已排序的元素小于或等于新元素的位置</li>
                        <li>将新元素插入到该位置</li>
                        <li>重复步骤2~5，直到所有元素排序完成</li>
                    </ol>
                    
                    <div class="bg-gray-100 p-4 rounded-lg mt-6">
                        <h3 class="text-lg font-semibold mb-2">算法过程可视化</h3>
                        <svg viewBox="0 0 400 200" xmlns="http://www.w3.org/2000/svg" class="w-full">
                            <!-- 初始数组 -->
                            <g transform="translate(20, 30)">
                                <text x="0" y="-10" font-size="14" fill="#333">初始数组</text>
                                <rect x="0" y="0" width="40" height="40" fill="#06b6d4" rx="4"></rect>
                                <rect x="45" y="0" width="40" height="40" fill="#06b6d4" rx="4"></rect>
                                <rect x="90" y="0" width="40" height="40" fill="#06b6d4" rx="4"></rect>
                                <rect x="135" y="0" width="40" height="40" fill="#06b6d4" rx="4"></rect>
                                <rect x="180" y="0" width="40" height="40" fill="#06b6d4" rx="4"></rect>
                                
                                <text x="20" y="25" font-size="16" fill="white" text-anchor="middle">5</text>
                                <text x="65" y="25" font-size="16" fill="white" text-anchor="middle">2</text>
                                <text x="110" y="25" font-size="16" fill="white" text-anchor="middle">4</text>
                                <text x="155" y="25" font-size="16" fill="white" text-anchor="middle">6</text>
                                <text x="200" y="25" font-size="16" fill="white" text-anchor="middle">1</text>
                            </g>
                            
                            <!-- 第一次迭代后 -->
                            <g transform="translate(20, 100)">
                                <text x="0" y="-10" font-size="14" fill="#333">第一次插入后</text>
                                <rect x="0" y="0" width="40" height="40" fill="#10B981" rx="4"></rect>
                                <rect x="45" y="0" width="40" height="40" fill="#10B981" rx="4"></rect>
                                <rect x="90" y="0" width="40" height="40" fill="#06b6d4" rx="4"></rect>
                                <rect x="135" y="0" width="40" height="40" fill="#06b6d4" rx="4"></rect>
                                <rect x="180" y="0" width="40" height="40" fill="#06b6d4" rx="4"></rect>
                                
                                <text x="20" y="25" font-size="16" fill="white" text-anchor="middle">2</text>
                                <text x="65" y="25" font-size="16" fill="white" text-anchor="middle">5</text>
                                <text x="110" y="25" font-size="16" fill="white" text-anchor="middle">4</text>
                                <text x="155" y="25" font-size="16" fill="white" text-anchor="middle">6</text>
                                <text x="200" y="25" font-size="16" fill="white" text-anchor="middle">1</text>
                                
                                <!-- 插入箭头 -->
                                <path d="M 65,45 L 65,60 L 20,60 L 20,45" stroke="#EF4444" stroke-width="2" fill="none" marker-end="url(#arrowhead)"></path>
                            </g>
                            
                            <!-- 箭头标记 -->
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#EF4444"/>
                                </marker>
                            </defs>
                        </svg>
                    </div>
                </div>
            </section>

            <!-- 算法实现 Section -->
            <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                <div class="flex items-center mb-6">
                    <i class="fas fa-code text-primary text-xl mr-3"></i>
                    <h2 class="text-2xl font-bold text-gray-800">算法实现</h2>
                </div>
                <div class="space-y-4 text-gray-700">
                    <p>以下是插入排序的C++实现：</p>
                    
                    <div class="overflow-x-auto bg-codeBlock rounded-lg p-4 mb-4 code-block">
                        <pre class="text-gray-100 font-mono text-sm"><code>// 插入排序
template &lt;typename T&gt;
void insertionSort(T arr[], int n) {
    for (int i = 1; i < n; i++) {
        // 保存当前要插入的元素
        T key = arr[i];
        // 从已排序序列的末尾开始比较
        int j = i - 1;
        
        // 将比key大的元素后移一位
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        // 找到key的正确位置，插入
        arr[j + 1] = key;
    }
}</code></pre>
                    </div>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">算法分析</h3>
                    <table class="min-w-full bg-white border border-gray-200 mb-4">
                        <thead>
                            <tr class="bg-gray-100">
                                <th class="py-3 px-4 border-b text-left">性能指标</th>
                                <th class="py-3 px-4 border-b text-left">结果</th>
                                <th class="py-3 px-4 border-b text-left">说明</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="py-3 px-4 border-b font-medium">时间复杂度（最好）</td>
                                <td class="py-3 px-4 border-b">O(n)</td>
                                <td class="py-3 px-4 border-b">当数组已经有序时，只需要n-1次比较，没有元素移动</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-medium">时间复杂度（平均）</td>
                                <td class="py-3 px-4 border-b">O(n²)</td>
                                <td class="py-3 px-4 border-b">需要进行n²/4次比较和n²/4次移动</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-medium">时间复杂度（最坏）</td>
                                <td class="py-3 px-4 border-b">O(n²)</td>
                                <td class="py-3 px-4 border-b">当数组完全逆序时，需要n²/2次比较和n²/2次移动</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-medium">空间复杂度</td>
                                <td class="py-3 px-4 border-b">O(1)</td>
                                <td class="py-3 px-4 border-b">只需要一个额外变量来存储当前待插入的元素</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-medium">稳定性</td>
                                <td class="py-3 px-4 border-b">稳定</td>
                                <td class="py-3 px-4 border-b">相等元素的相对位置不会改变</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-medium">原地排序</td>
                                <td class="py-3 px-4 border-b">是</td>
                                <td class="py-3 px-4 border-b">不需要额外的数组空间</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r mb-4">
                        <div class="flex items-start">
                            <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-3"></i>
                            <p class="text-gray-700">
                                <strong>优势</strong>：插入排序在几乎已排序的数组上表现出色，时间复杂度接近于线性。它的实现简单，对于小型数组（通常少于50个元素）性能优于更复杂的排序算法，这也是为什么许多高级排序算法在处理小规模子数组时会切换到插入排序。
                            </p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 算法优化 Section -->
            <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                <div class="flex items-center mb-6">
                    <i class="fas fa-lightbulb text-primary text-xl mr-3"></i>
                    <h2 class="text-2xl font-bold text-gray-800">算法优化</h2>
                </div>
                <div class="space-y-4 text-gray-700">
                    <p>虽然插入排序在基本形式下已经对部分有序数据有着不错的性能，但还可以进一步优化：</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                        <div class="card-hover p-6 bg-gray-50 rounded-xl">
                            <h3 class="text-lg font-semibold text-gray-800 mb-3">二分查找插入排序</h3>
                            <p>使用二分查找来快速找到插入位置，减少比较次数，但移动操作次数不变。</p>
                            <div class="mt-3">
                                <p class="text-sm">实现示例：</p>
                                <div class="overflow-x-auto bg-codeBlock rounded-lg p-3 mt-2 code-block">
                                    <pre class="text-gray-100 font-mono text-xs"><code>template &lt;typename T&gt;
void binaryInsertionSort(T arr[], int n) {
    for (int i = 1; i < n; i++) {
        // 保存当前要插入的元素
        T key = arr[i];
        
        // 使用二分查找找到插入位置
        int left = 0;
        int right = i - 1;
        int mid;
        
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (arr[mid] > key)
                right = mid - 1;
            else
                left = mid + 1;
        }
        
        // left 是插入位置
        // 将插入位置之后的元素后移
        for (int j = i - 1; j >= left; j--) {
            arr[j + 1] = arr[j];
        }
        
        // 插入元素
        arr[left] = key;
    }
}</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div class="card-hover p-6 bg-gray-50 rounded-xl">
                            <h3 class="text-lg font-semibold text-gray-800 mb-3">希尔排序</h3>
                            <p>插入排序的高级变种，通过将数组分组并对每组使用插入排序，可以将时间复杂度降至O(n log² n)。</p>
                            <div class="mt-3">
                                <p class="text-sm">基本思想：</p>
                                <ul class="list-disc pl-5 space-y-1 text-sm">
                                    <li>选择一个增量序列 t₁, t₂, ..., tₖ, ..., t₁</li>
                                    <li>按增量序列对数组进行分组</li>
                                    <li>对每组使用直接插入排序</li>
                                    <li>随着增量逐渐减少，数组越来越接近有序</li>
                                    <li>最后增量为1时，完成排序</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">优化对比</h3>
                    <div class="overflow-x-auto mb-6">
                        <table class="min-w-full bg-white border border-gray-200">
                            <thead>
                                <tr class="bg-gray-100">
                                    <th class="py-3 px-4 border-b text-left">优化方法</th>
                                    <th class="py-3 px-4 border-b text-left">时间复杂度(最好)</th>
                                    <th class="py-3 px-4 border-b text-left">时间复杂度(平均)</th>
                                    <th class="py-3 px-4 border-b text-left">稳定性</th>
                                    <th class="py-3 px-4 border-b text-left">优势</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="py-3 px-4 border-b">基本插入排序</td>
                                    <td class="py-3 px-4 border-b">O(n)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">稳定</td>
                                    <td class="py-3 px-4 border-b">简单易实现，部分有序数据高效</td>
                                </tr>
                                <tr>
                                    <td class="py-3 px-4 border-b">二分插入排序</td>
                                    <td class="py-3 px-4 border-b">O(n log n)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">稳定</td>
                                    <td class="py-3 px-4 border-b">减少比较次数，但移动次数不变</td>
                                </tr>
                                <tr>
                                    <td class="py-3 px-4 border-b">希尔排序</td>
                                    <td class="py-3 px-4 border-b">O(n log n)</td>
                                    <td class="py-3 px-4 border-b">O(n log² n)</td>
                                    <td class="py-3 px-4 border-b">不稳定</td>
                                    <td class="py-3 px-4 border-b">显著改善大数组的性能</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="p-5 bg-gray-50 rounded-xl">
                        <h3 class="text-lg font-semibold text-gray-800 mb-3">缓存友好性分析</h3>
                        <p>插入排序具有出色的缓存局部性（cache locality），因为它主要对相邻元素进行比较和交换，这使得它在现代计算机架构上的实际性能往往好于其理论复杂度所预测的性能。这也是为什么许多标准库在实现排序算法时，会在小规模数据上使用插入排序作为快速排序或归并排序的补充。</p>
                    </div>
                </div>
            </section>

            <!-- 算法应用与示例 Section -->
            <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                <div class="flex items-center mb-6">
                    <i class="fas fa-flask text-primary text-xl mr-3"></i>
                    <h2 class="text-2xl font-bold text-gray-800">算法应用与示例</h2>
                </div>
                <div class="space-y-4 text-gray-700">
                    <h3 class="text-xl font-semibold text-gray-800 mb-3">1. 扑克牌排序</h3>
                    <p>插入排序非常类似于我们整理扑克牌的方式，以下是一个模拟扑克牌排序的例子：</p>
                    
                    <div class="overflow-x-auto bg-codeBlock rounded-lg p-4 mb-4 code-block">
                        <pre class="text-gray-100 font-mono text-sm"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

enum Suit { SPADE, HEART, CLUB, DIAMOND };
enum Rank { TWO=2, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE };

struct Card {
    Suit suit;
    Rank rank;
    
    // 重载小于运算符，用于排序
    bool operator<(const Card& other) const {
        if (suit == other.suit)
            return rank < other.rank;
        return suit < other.suit;
    }
};

// 获取卡牌描述
std::string getCardDescription(const Card& card) {
    std::string suitStr;
    switch(card.suit) {
        case SPADE: suitStr = "黑桃"; break;
        case HEART: suitStr = "红心"; break;
        case CLUB: suitStr = "梅花"; break;
        case DIAMOND: suitStr = "方块"; break;
    }
    
    std::string rankStr;
    switch(card.rank) {
        case ACE: rankStr = "A"; break;
        case KING: rankStr = "K"; break;
        case QUEEN: rankStr = "Q"; break;
        case JACK: rankStr = "J"; break;
        default: rankStr = std::to_string(card.rank); break;
    }
    
    return suitStr + rankStr;
}

// 插入排序排列扑克牌
void sortCards(std::vector<Card>& cards) {
    for (int i = 1; i < cards.size(); i++) {
        Card key = cards[i];
        int j = i - 1;
        
        // 将比key大的卡牌向右移动
        while (j >= 0 && !(key < cards[j])) {
            cards[j + 1] = cards[j];
            j--;
        }
        
        // 插入当前卡牌到正确位置
        cards[j + 1] = key;
    }
}

int main() {
    // 创建一个乱序的卡牌集合
    std::vector<Card> cards = {
        {HEART, FIVE}, {SPADE, ACE}, {DIAMOND, KING},
        {CLUB, SEVEN}, {HEART, QUEEN}, {SPADE, THREE}
    };
    
    std::cout << "排序前: ";
    for (const auto& card : cards) {
        std::cout << getCardDescription(card) << " ";
    }
    std::cout << std::endl;
    
    // 排序卡牌
    sortCards(cards);
    
    std::cout << "排序后: ";
    for (const auto& card : cards) {
        std::cout << getCardDescription(card) << " ";
    }
    std::cout << std::endl;
    
    return 0;
}</code></pre>
                    </div>
                    <p>输出结果：</p>
                    <div class="bg-gray-100 p-4 rounded-lg mb-6">
                        <pre class="font-mono text-sm">排序前: 红心5 黑桃A 方块K 梅花7 红心Q 黑桃3
排序后: 黑桃3 黑桃A 红心5 红心Q 梅花7 方块K</pre>
                    </div>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">2. 在线处理数据流</h3>
                    <p>插入排序的一个重要应用是处理实时到达的数据流，保持有序序列：</p>
                    
                    <div class="overflow-x-auto bg-codeBlock rounded-lg p-4 mb-4 code-block">
                        <pre class="text-gray-100 font-mono text-sm"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

// 在有序数组中插入新元素并保持有序
void insertSorted(std::vector<int>& arr, int newValue) {
    // 找到插入位置（使用二分查找优化）
    auto it = std::lower_bound(arr.begin(), arr.end(), newValue);
    // 插入新元素
    arr.insert(it, newValue);
}

int main() {
    // 模拟实时数据流处理
    std::vector<int> sortedStream;
    
    // 接收数据并保持有序
    std::cout << "模拟数据流处理：" << std::endl;
    
    insertSorted(sortedStream, 42);
    std::cout << "收到数据42，当前序列: ";
    for (int num : sortedStream) std::cout << num << " ";
    std::cout << std::endl;
    
    insertSorted(sortedStream, 17);
    std::cout << "收到数据17，当前序列: ";
    for (int num : sortedStream) std::cout << num << " ";
    std::cout << std::endl;
    
    insertSorted(sortedStream, 56);
    std::cout << "收到数据56，当前序列: ";
    for (int num : sortedStream) std::cout << num << " ";
    std::cout << std::endl;
    
    insertSorted(sortedStream, 23);
    std::cout << "收到数据23，当前序列: ";
    for (int num : sortedStream) std::cout << num << " ";
    std::cout << std::endl;
    
    insertSorted(sortedStream, 33);
    std::cout << "收到数据33，当前序列: ";
    for (int num : sortedStream) std::cout << num << " ";
    std::cout << std::endl;
    
    return 0;
}</code></pre>
                    </div>
                    <p>输出结果：</p>
                    <div class="bg-gray-100 p-4 rounded-lg mb-6">
                        <pre class="font-mono text-sm">模拟数据流处理：
收到数据42，当前序列: 42 
收到数据17，当前序列: 17 42 
收到数据56，当前序列: 17 42 56 
收到数据23，当前序列: 17 23 42 56 
收到数据33，当前序列: 17 23 33 42 56 </pre>
                    </div>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">3. 适用场景</h3>
                    <div class="p-5 bg-gray-50 rounded-xl">
                        <ul class="list-disc list-inside space-y-3 pl-4">
                            <li><strong>小型数据集</strong>：插入排序在处理少量元素的数组时非常高效</li>
                            <li><strong>几乎有序的数据</strong>：当数据已经接近有序状态时，插入排序接近O(n)复杂度</li>
                            <li><strong>在线算法要求</strong>：可以随时处理新到达的元素</li>
                            <li><strong>辅助排序算法</strong>：作为高级排序算法(如快速排序)的子过程</li>
                            <li><strong>资源受限环境</strong>：实现简单，内存占用少，适用于嵌入式系统</li>
                        </ul>
                    </div>

                    <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r mt-6">
                        <div class="flex items-start">
                            <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-3"></i>
                            <div>
                                <h4 class="font-semibold text-gray-800 mb-2">插入排序在实际应用中的优势</h4>
                                <ul class="list-disc pl-5 space-y-1 text-gray-700">
                                    <li>可以部分排序，不需要等待所有数据都到达</li>
                                    <li>对于短数组，通常比其他排序算法更快</li>
                                    <li>在实现上比快速排序或归并排序更简单</li>
                                    <li>STL中的std::sort在数据量小时常切换到插入排序</li>
                                    <li>对于嵌入式系统，插入排序的空间复杂度为O(1)是一个重要优势</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 算法比较 Section -->
            <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                <div class="flex items-center mb-6">
                    <i class="fas fa-balance-scale text-primary text-xl mr-3"></i>
                    <h2 class="text-2xl font-bold text-gray-800">算法比较</h2>
                </div>
                <div class="space-y-4 text-gray-700">
                    <p>插入排序与其他常见排序算法的比较：</p>
                    
                    <div class="overflow-x-auto mb-6">
                        <table class="min-w-full bg-white border border-gray-200">
                            <thead>
                                <tr class="bg-gray-100">
                                    <th class="py-3 px-4 border-b text-left">算法</th>
                                    <th class="py-3 px-4 border-b text-left">最好时间复杂度</th>
                                    <th class="py-3 px-4 border-b text-left">平均时间复杂度</th>
                                    <th class="py-3 px-4 border-b text-left">最差时间复杂度</th>
                                    <th class="py-3 px-4 border-b text-left">空间复杂度</th>
                                    <th class="py-3 px-4 border-b text-left">稳定性</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="bg-primary-light bg-opacity-20">
                                    <td class="py-3 px-4 border-b font-semibold">插入排序</td>
                                    <td class="py-3 px-4 border-b">O(n)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">O(1)</td>
                                    <td class="py-3 px-4 border-b">稳定</td>
                                </tr>
                                <tr>
                                    <td class="py-3 px-4 border-b">选择排序</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">O(1)</td>
                                    <td class="py-3 px-4 border-b">不稳定</td>
                                </tr>
                                <tr>
                                    <td class="py-3 px-4 border-b">冒泡排序</td>
                                    <td class="py-3 px-4 border-b">O(n)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">O(1)</td>
                                    <td class="py-3 px-4 border-b">稳定</td>
                                </tr>
                                <tr>
                                    <td class="py-3 px-4 border-b">快速排序</td>
                                    <td class="py-3 px-4 border-b">O(n log n)</td>
                                    <td class="py-3 px-4 border-b">O(n log n)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">O(log n)</td>
                                    <td class="py-3 px-4 border-b">不稳定</td>
                                </tr>
                                <tr>
                                    <td class="py-3 px-4 border-b">归并排序</td>
                                    <td class="py-3 px-4 border-b">O(n log n)</td>
                                    <td class="py-3 px-4 border-b">O(n log n)</td>
                                    <td class="py-3 px-4 border-b">O(n log n)</td>
                                    <td class="py-3 px-4 border-b">O(n)</td>
                                    <td class="py-3 px-4 border-b">稳定</td>
                                </tr>
                                <tr>
                                    <td class="py-3 px-4 border-b">希尔排序</td>
                                    <td class="py-3 px-4 border-b">O(n log n)</td>
                                    <td class="py-3 px-4 border-b">O(n log² n)</td>
                                    <td class="py-3 px-4 border-b">O(n²)</td>
                                    <td class="py-3 px-4 border-b">O(1)</td>
                                    <td class="py-3 px-4 border-b">不稳定</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">各算法的优缺点对比</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                        <div class="card-hover p-6 bg-gray-50 rounded-xl">
                            <h4 class="text-lg font-semibold text-gray-800 mb-3">插入排序的优点</h4>
                            <ul class="list-disc pl-6 space-y-1">
                                <li>对小规模数据效率高</li>
                                <li>对接近有序的数据排序接近线性时间</li>
                                <li>是稳定排序算法</li>
                                <li>空间复杂度低，为O(1)</li>
                                <li>可以处理动态数据流（在线算法）</li>
                                <li>实现简单直观</li>
                            </ul>
                        </div>
                        
                        <div class="card-hover p-6 bg-gray-50 rounded-xl">
                            <h4 class="text-lg font-semibold text-gray-800 mb-3">插入排序的缺点</h4>
                            <ul class="list-disc pl-6 space-y-1">
                                <li>平均时间复杂度为O(n²)，对大数据集效率低</li>
                                <li>对逆序数据效率特别低</li>
                                <li>元素移动操作较多</li>
                                <li>不适合对数组进行远距离元素移动</li>
                                <li>对于链表结构，查找插入位置需要O(n)时间</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="p-5 bg-primary-light bg-opacity-10 rounded-lg mt-6">
                        <p class="font-semibold mb-2">插入排序与选择排序和冒泡排序的比较</p>
                        <p>虽然插入排序、选择排序和冒泡排序都属于简单的O(n²)排序算法，但插入排序通常是这三者中最实用的：</p>
                        <ul class="list-disc pl-6 mt-2 space-y-1">
                            <li>相比选择排序，插入排序是稳定的，且对部分有序数据表现更好</li>
                            <li>相比冒泡排序，插入排序通常需要更少的写操作，且有更好的局部性</li>
                            <li>插入排序在大多数现代CPU上表现好于冒泡排序和选择排序，因为它具有更好的缓存局部性</li>
                            <li>在实际应用中，标准库的排序算法通常在小范围子数组上使用插入排序，而非选择或冒泡排序</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- 完整排序过程 Section -->
            <section class="mb-12 bg-white rounded-lg shadow-md p-6 transition-all duration-300 hover:shadow-lg">
                <h2 class="text-2xl font-bold mb-4 text-primary-dark flex items-center">
                    <i class="fas fa-sync-alt mr-2"></i>完整排序过程
                </h2>
                <p class="mb-4">以下是插入排序的完整过程演示：</p>
                
                <!-- 注意：交互式可视化已移至下方专门的节 -->
                <div class="p-5 bg-primary-light bg-opacity-10 rounded-lg mt-6 text-center">
                    <div class="flex items-start justify-center">
                        <i class="fas fa-arrow-down text-primary-dark mt-1 mr-3 text-xl"></i>
                        <p class="text-gray-700 font-medium">
                            请查看下方"交互式可视化"部分以体验插入排序的动态演示。
                        </p>
                    </div>
                </div>
            </section>

            <!-- 交互式可视化 Section -->
            <section class="mb-12 bg-white rounded-2xl shadow-md p-8">
                <div class="flex items-center mb-6">
                    <i class="fas fa-chart-bar text-primary text-xl mr-3"></i>
                    <h2 class="text-2xl font-bold text-gray-800">交互式可视化</h2>
                </div>
                <div class="space-y-6 text-gray-700">
                    <p>通过下面的交互式演示，您可以亲自体验插入排序的运行过程。观察每一步比较和移动操作，理解算法的工作原理。</p>
                    
                    <div class="flex flex-col items-center p-6 bg-gray-50 rounded-xl">
                        <!-- 数组可视化区域 -->
                        <div id="array-container" class="w-full h-64 bg-white rounded-lg shadow-inner p-4 mb-6 flex items-end justify-center">
                            <!-- 柱状图将在这里动态生成 -->
                        </div>
                        
                        <!-- 控制按钮 -->
                        <div class="flex flex-wrap gap-4 justify-center mb-6">
                            <button id="new-array" class="px-4 py-2 bg-primary hover:bg-primary-dark text-white rounded-lg transition duration-300 flex items-center">
                                <i class="fas fa-random mr-2"></i> 生成新数组
                            </button>
                            <button id="start" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition duration-300 flex items-center">
                                <i class="fas fa-play mr-2"></i> 开始演示
                            </button>
                            <button id="pause" class="px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded-lg transition duration-300 flex items-center" disabled>
                                <i class="fas fa-pause mr-2"></i> 暂停
                            </button>
                            <button id="reset" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg transition duration-300 flex items-center" disabled>
                                <i class="fas fa-undo mr-2"></i> 重置
                            </button>
                        </div>
                        
                        <!-- 速度控制 -->
                        <div class="w-full max-w-md flex items-center mb-6">
                            <span class="mr-3 text-sm font-medium text-gray-700">速度:</span>
                            <input id="speed-slider" type="range" min="1" max="5" value="3" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <span class="ml-3 text-sm font-medium text-gray-700" id="speed-value">中等</span>
                        </div>
                        
                        <!-- 当前状态显示 -->
                        <div class="w-full grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                            <div class="p-3 bg-blue-100 rounded-lg">
                                <div class="flex items-center">
                                    <div class="w-4 h-4 bg-blue-500 rounded-sm mr-2"></div>
                                    <span class="text-sm text-gray-700">当前元素</span>
                                </div>
                            </div>
                            <div class="p-3 bg-red-100 rounded-lg">
                                <div class="flex items-center">
                                    <div class="w-4 h-4 bg-red-500 rounded-sm mr-2"></div>
                                    <span class="text-sm text-gray-700">比较元素</span>
                                </div>
                            </div>
                            <div class="p-3 bg-green-100 rounded-lg">
                                <div class="flex items-center">
                                    <div class="w-4 h-4 bg-green-500 rounded-sm mr-2"></div>
                                    <span class="text-sm text-gray-700">已排序元素</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <h3 class="text-xl font-semibold text-gray-800 mt-8 mb-4">算法实现</h3>
                    <pre class="code-block bg-codeBlock text-white p-4 rounded-lg overflow-x-auto">
<code class="language-cpp">void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        // 保存当前要插入的元素
        int key = arr[i];
        // 从已排序序列的末尾开始比较
        int j = i - 1;
        
        // 将比key大的元素后移一位
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        // 找到key的正确位置，插入
        arr[j + 1] = key;
    }
}</code>
                    </pre>
                </div>
                
                <!-- JavaScript 实现可视化 -->
                <script>
                    // 元素样式类
                    const NORMAL = 'bg-gray-300';
                    const CURRENT = 'bg-blue-500';
                    const COMPARING = 'bg-red-500';
                    const SORTED = 'bg-green-500';
                    const MOVING = 'bg-yellow-500';
                    
                    // 全局变量
                    let array = [];
                    let arrayBars = [];
                    let sortingInProgress = false;
                    let sortingPaused = false;
                    let sortingTimeout = null;
                    
                    // DOM 元素
                    let arrayContainer;
                    let newArrayBtn;
                    let startBtn;
                    let pauseBtn;
                    let resetBtn;
                    let speedSlider;
                    let speedValue;
                    
                    // 初始化
                    function init() {
                        console.log("Initializing insertion sort visualization...");
                        // 获取DOM元素
                        arrayContainer = document.getElementById('array-container');
                        newArrayBtn = document.getElementById('new-array');
                        startBtn = document.getElementById('start');
                        pauseBtn = document.getElementById('pause');
                        resetBtn = document.getElementById('reset');
                        speedSlider = document.getElementById('speed-slider');
                        speedValue = document.getElementById('speed-value');
                        
                        if (!arrayContainer || !newArrayBtn || !startBtn || !pauseBtn || !resetBtn || !speedSlider || !speedValue) {
                            console.error("Failed to find all required DOM elements");
                            return;
                        }
                        
                        console.log("DOM elements found successfully");
                        
                        generateNewArray();
                        updateSpeedText();
                        
                        // 事件监听器
                        newArrayBtn.addEventListener('click', function() {
                            console.log("New array button clicked");
                            generateNewArray();
                        });
                        
                        startBtn.addEventListener('click', function() {
                            console.log("Start button clicked");
                            startSorting();
                        });
                        
                        pauseBtn.addEventListener('click', function() {
                            console.log("Pause button clicked");
                            togglePause();
                        });
                        
                        resetBtn.addEventListener('click', function() {
                            console.log("Reset button clicked");
                            resetSorting();
                        });
                        
                        speedSlider.addEventListener('input', updateSpeedText);
                        
                        console.log("Insertion sort visualization initialized");
                    }
                    
                    // 生成新数组
                    function generateNewArray() {
                        resetSorting();
                        array = [];
                        arrayContainer.innerHTML = '';
                        arrayBars = [];
                        
                        // 生成随机数组
                        const size = 15; // 数组大小
                        const maxValue = 100;
                        for (let i = 0; i < size; i++) {
                            array.push(Math.floor(Math.random() * maxValue) + 5);
                        }
                        
                        console.log("Generated new array:", array);
                        
                        // 创建可视化柱状图
                        const maxHeight = arrayContainer.clientHeight - 20;
                        const barWidth = Math.floor((arrayContainer.clientWidth - size * 4) / size);
                        
                        for (let i = 0; i < array.length; i++) {
                            const barHeight = Math.floor((array[i] / maxValue) * maxHeight);
                            const bar = document.createElement('div');
                            bar.classList.add(NORMAL, 'mx-1', 'rounded-t-sm', 'flex', 'items-end', 'justify-center', 'transition-all', 'duration-200');
                            bar.style.height = `${barHeight}px`;
                            bar.style.width = `${barWidth}px`;
                            
                            const label = document.createElement('span');
                            label.textContent = array[i];
                            label.classList.add('text-xs', 'font-medium', 'text-white', 'mb-1');
                            bar.appendChild(label);
                            
                            arrayContainer.appendChild(bar);
                            arrayBars.push(bar);
                        }
                    }
                    
                    // 更新速度文本
                    function updateSpeedText() {
                        const speed = speedSlider.value;
                        let speedText = '';
                        
                        switch (parseInt(speed)) {
                            case 1: speedText = '非常慢'; break;
                            case 2: speedText = '慢'; break;
                            case 3: speedText = '中等'; break;
                            case 4: speedText = '快'; break;
                            case 5: speedText = '非常快'; break;
                        }
                        
                        speedValue.textContent = speedText;
                    }
                    
                    // 获取当前速度的毫秒延迟
                    function getDelay() {
                        const speed = parseInt(speedSlider.value);
                        switch (speed) {
                            case 1: return 1000;
                            case 2: return 500;
                            case 3: return 250;
                            case 4: return 100;
                            case 5: return 50;
                            default: return 250;
                        }
                    }
                    
                    // 启动排序
                    function startSorting() {
                        if (sortingInProgress) return;
                        
                        sortingInProgress = true;
                        sortingPaused = false;
                        startBtn.disabled = true;
                        newArrayBtn.disabled = true;
                        pauseBtn.disabled = false;
                        resetBtn.disabled = false;
                        
                        // 开始插入排序
                        insertionSort();
                    }
                    
                    // 暂停/继续排序
                    function togglePause() {
                        sortingPaused = !sortingPaused;
                        pauseBtn.innerHTML = sortingPaused ? 
                            '<i class="fas fa-play mr-2"></i> 继续' : 
                            '<i class="fas fa-pause mr-2"></i> 暂停';
                    }
                    
                    // 重置排序
                    function resetSorting() {
                        if (sortingTimeout) {
                            clearTimeout(sortingTimeout);
                            sortingTimeout = null;
                        }
                        
                        sortingInProgress = false;
                        sortingPaused = false;
                        
                        startBtn.disabled = false;
                        newArrayBtn.disabled = false;
                        pauseBtn.disabled = true;
                        resetBtn.disabled = true;
                        pauseBtn.innerHTML = '<i class="fas fa-pause mr-2"></i> 暂停';
                        
                        // 重置所有柱状图样式
                        if (arrayBars.length > 0) {
                            arrayBars.forEach(bar => {
                                bar.className = '';
                                bar.classList.add(NORMAL, 'mx-1', 'rounded-t-sm', 'flex', 'items-end', 'justify-center', 'transition-all', 'duration-200');
                            });
                        }
                    }
                    
                    // 插入排序可视化实现
                    async function insertionSort() {
                        const delay = getDelay();
                        const n = array.length;
                        
                        // 第一个元素视为已排序
                        arrayBars[0].classList.remove(NORMAL);
                        arrayBars[0].classList.add(SORTED);
                        
                        await new Promise(resolve => setTimeout(resolve, delay));
                        
                        // 从第二个元素开始插入排序
                        for (let i = 1; i < n; i++) {
                            if (!sortingInProgress) return;
                            
                            // 暂停检查
                            if (sortingPaused) {
                                await new Promise(resolve => {
                                    function checkPauseStatus() {
                                        if (sortingPaused) {
                                            sortingTimeout = setTimeout(checkPauseStatus, 100);
                                        } else {
                                            resolve();
                                        }
                                    }
                                    checkPauseStatus();
                                });
                            }
                            
                            // 标记当前要插入的元素
                            const key = array[i];
                            arrayBars[i].classList.remove(NORMAL);
                            arrayBars[i].classList.add(CURRENT);
                            
                            await new Promise(resolve => setTimeout(resolve, delay));
                            
                            let j = i - 1;
                            
                            // 保存当前要插入的元素的样式和高度
                            const currentHeight = arrayBars[i].style.height;
                            const currentText = arrayBars[i].firstChild.textContent;
                            
                            // 寻找插入位置并后移元素
                            while (j >= 0 && array[j] > key) {
                                if (!sortingInProgress) return;
                                
                                // 暂停检查
                                if (sortingPaused) {
                                    await new Promise(resolve => {
                                        function checkPauseStatus() {
                                            if (sortingPaused) {
                                                sortingTimeout = setTimeout(checkPauseStatus, 100);
                                            } else {
                                                resolve();
                                            }
                                        }
                                        checkPauseStatus();
                                    });
                                }
                                
                                // 标记比较元素
                                arrayBars[j].classList.remove(SORTED);
                                arrayBars[j].classList.add(COMPARING);
                                
                                await new Promise(resolve => setTimeout(resolve, delay));
                                
                                // 移动元素
                                array[j + 1] = array[j];
                                arrayBars[j + 1].style.height = arrayBars[j].style.height;
                                arrayBars[j + 1].firstChild.textContent = arrayBars[j].firstChild.textContent;
                                
                                // 恢复比较元素样式
                                arrayBars[j].classList.remove(COMPARING);
                                arrayBars[j].classList.add(SORTED);
                                
                                j--;
                            }
                            
                            // 插入元素到正确位置
                            array[j + 1] = key;
                            arrayBars[j + 1].style.height = currentHeight;
                            arrayBars[j + 1].firstChild.textContent = currentText;
                            
                            // 更新所有已排序元素的样式
                            for (let k = 0; k <= i; k++) {
                                arrayBars[k].className = '';
                                arrayBars[k].classList.add(SORTED, 'mx-1', 'rounded-t-sm', 'flex', 'items-end', 'justify-center', 'transition-all', 'duration-200');
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                        
                        // 排序完成
                        sortingInProgress = false;
                        startBtn.disabled = true;
                        newArrayBtn.disabled = false;
                        pauseBtn.disabled = true;
                        resetBtn.disabled = false;
                    }
                    
                    // 页面加载完成后初始化
                    document.addEventListener('DOMContentLoaded', init);
                </script>
            </section>
        </main>
        
        
        <!-- 页脚 -->
        <footer class="mt-10 p-6 bg-gray-800 text-white flex flex-col md:flex-row justify-between items-center">
            <div class="mb-4 md:mb-0">
                <p class="text-sm"></p>
            </div>
            <div class="flex space-x-4">
                <a href="index.html" class="text-gray-300 hover:text-white transition-colors">首页</a>
                <a href="计数排序.html" class="text-gray-300 hover:text-white transition-colors">计数排序</a>
                <a href="快速排序.html" class="text-gray-300 hover:text-white transition-colors">快速排序</a>
                <a href="归并排序.html" class="text-gray-300 hover:text-white transition-colors">归并排序</a>
            </div>
        </footer>
    </div>

    <!-- Back to top button -->
    <button id="backToTop" class="fixed bottom-6 right-6 bg-primary hover:bg-primary-dark text-white rounded-full p-3 shadow-lg transition-all duration-300 opacity-0 invisible">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- JavaScript for Back to top button -->
    <script>
        const backToTop = document.getElementById('backToTop');
        
        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                backToTop.classList.remove('opacity-0', 'invisible');
                backToTop.classList.add('opacity-100', 'visible');
            } else {
                backToTop.classList.remove('opacity-100', 'visible');
                backToTop.classList.add('opacity-0', 'invisible');
            }
        });
        
        backToTop.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    </script>
    <!-- Simple ScrollReveal effect -->
    <script src="https://unpkg.com/scrollreveal"></script>
    <script>
        ScrollReveal().reveal('section', { 
            delay: 200,
            distance: '20px',
            origin: 'bottom',
            duration: 800,
            easing: 'ease-in-out'
        });
    </script>
    </div>
</body>
</html> 