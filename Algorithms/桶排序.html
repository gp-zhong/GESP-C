<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>桶排序</title>
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            light: '#a5f3fc',
                            DEFAULT: '#06b6d4',
                            dark: '#0891b2',
                        },
                        secondary: {
                            light: '#c7d2fe',
                            DEFAULT: '#818cf8',
                            dark: '#6366f1',
                        },
                        codeBlock: '#1e293b',
                    },
                    fontFamily: {
                        sans: ['Poppins', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        .card-hover {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card-hover:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(6, 182, 212, 0.1), 0 10px 10px -5px rgba(6, 182, 212, 0.04);
        }
        .code-block::-webkit-scrollbar {
            height: 8px;
        }
        .code-block::-webkit-scrollbar-thumb {
            background-color: #06b6d4;
            border-radius: 4px;
        }
        .code-block::-webkit-scrollbar-track {
            background-color: #e2e8f0;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="min-h-screen max-w-6xl mx-auto px-8 py-10">
        <!-- Header -->
        <header class="mb-12 text-center">
            <div class="inline-block px-3 py-1 bg-primary-light text-primary-dark rounded-full text-sm font-medium mb-4">
                算法基础
            </div>
            <h1 class="text-4xl font-bold text-gray-800 mb-4">桶排序</h1>
            <p class="text-lg text-gray-600 max-w-3xl mx-auto">一种将元素分配到不同桶中再排序的高效排序算法</p>
        </header>

        <!-- Main Content -->
        <main class="space-y-12">
            <!-- 算法简介 -->
            <section id="intro">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-info-circle text-primary mr-3"></i>算法简介
                </h2>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <p class="text-gray-700 mb-4">桶排序（Bucket Sort）是一种分布式排序算法，其基本思想是：</p>
                    <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4 ml-4">
                        <li>将待排序数据分到有限数量的桶中</li>
                        <li>对每个桶内的数据进行排序（可以使用其他排序算法或递归使用桶排序）</li>
                        <li>最后按照顺序将各个桶中的元素合并得到有序序列</li>
                    </ul>
                    <p class="text-gray-700">桶排序假设输入数据服从均匀分布，平均情况下，桶排序的时间复杂度为O(n+k)，其中k是桶的数量。当输入数据近似均匀分布时，桶排序的效率非常高。</p>
                </div>
            </section>
            
            <!-- 算法特点 -->
            <section id="characteristics">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-star text-primary mr-3"></i>算法特点
                </h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-md card-hover">
                        <h3 class="text-xl font-medium text-gray-800 mb-3 flex items-center">
                            <i class="fas fa-check-circle text-green-500 mr-2"></i>优点
                        </h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700 ml-4">
                            <li>当数据均匀分布时，时间复杂度可以接近O(n)</li>
                            <li>适合外部排序（数据量大，无法一次性载入内存）</li>
                            <li>可以与其他排序算法结合使用</li>
                            <li>适合对浮点数排序</li>
                            <li>是一种稳定的排序算法</li>
                        </ul>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md card-hover">
                        <h3 class="text-xl font-medium text-gray-800 mb-3 flex items-center">
                            <i class="fas fa-exclamation-circle text-red-500 mr-2"></i>缺点
                        </h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700 ml-4">
                            <li>对数据分布有较强的依赖性</li>
                            <li>如果数据分布不均匀，可能导致桶排序的时间复杂度退化</li>
                            <li>需要额外的空间来存储桶</li>
                            <li>计算数据应该放入哪个桶需要额外计算</li>
                            <li>当数据分布极度不均匀时，效率可能低于其他排序算法</li>
                        </ul>
                    </div>
                </div>
            </section>
            
            <!-- 算法原理 -->
            <section id="principle">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-lightbulb text-primary mr-3"></i>算法原理
                </h2>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <p class="text-gray-700 mb-4">桶排序的基本原理是将数据分散到多个桶中，具体步骤如下：</p>
                    <ol class="list-decimal list-inside space-y-3 text-gray-700 mb-6 ml-4">
                        <li><span class="font-medium">创建桶：</span>根据数据范围创建n个空桶</li>
                        <li><span class="font-medium">分配数据：</span>将数据根据特定规则分配到各个桶中</li>
                        <li><span class="font-medium">桶内排序：</span>对每个非空桶内的数据进行排序</li>
                        <li><span class="font-medium">合并结果：</span>按顺序遍历每个桶，将桶内元素合并得到最终的有序序列</li>
                    </ol>
                    
                    <div class="bg-gray-100 p-5 rounded-lg">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">关键概念</h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700 ml-4">
                            <li><span class="font-medium">桶的数量：</span>通常与待排序数据数量相当，但可以根据实际情况调整</li>
                            <li><span class="font-medium">桶的划分：</span>按照数据的分布特性划分桶的范围（线性映射或自定义规则）</li>
                            <li><span class="font-medium">桶内排序算法：</span>可以使用插入排序、快速排序等算法，或递归使用桶排序</li>
                            <li><span class="font-medium">均匀分布：</span>桶排序的效率高度依赖于数据分布的均匀性</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- 算法演示 -->
            <section id="demo">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-play-circle text-primary mr-3"></i>算法演示
                </h2>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <p class="text-gray-700 mb-4">以数组 [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51, 0.78, 0.11, 0.23] 为例，展示桶排序的执行过程：</p>
                    
                    <div class="space-y-8 my-6">
                        <!-- 步骤 1 -->
                        <div>
                            <h3 class="text-lg font-medium text-gray-800 mb-2">步骤 1：创建桶</h3>
                            <p class="text-gray-700 mb-3">假设我们创建5个桶，每个桶的范围是0.2，即：[0.0-0.2), [0.2-0.4), [0.4-0.6), [0.6-0.8), [0.8-1.0)</p>
                            <div class="overflow-x-auto mb-4">
                                <table class="min-w-full border-collapse">
                                    <thead>
                                        <tr class="bg-gray-100">
                                            <th class="py-2 px-4 border">桶的范围</th>
                                            <th class="py-2 px-4 border">桶的编号</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.0-0.2)</td>
                                            <td class="py-2 px-4 border text-center">桶 0</td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.2-0.4)</td>
                                            <td class="py-2 px-4 border text-center">桶 1</td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.4-0.6)</td>
                                            <td class="py-2 px-4 border text-center">桶 2</td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.6-0.8)</td>
                                            <td class="py-2 px-4 border text-center">桶 3</td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.8-1.0)</td>
                                            <td class="py-2 px-4 border text-center">桶 4</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                            <div class="flex items-center justify-center space-x-2 my-4 flex-wrap">
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.42</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.32</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.33</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.52</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.37</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.47</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.51</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.78</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.11</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-primary-light text-gray-800 font-medium rounded">0.23</div>
                            </div>
                        </div>
                        
                        <!-- 步骤 2 -->
                        <div>
                            <h3 class="text-lg font-medium text-gray-800 mb-2">步骤 2：分配元素到桶中</h3>
                            <p class="text-gray-700 mb-3">根据元素值和桶的范围，将每个元素分配到对应的桶中</p>
                            
                            <div class="overflow-x-auto mb-4">
                                <table class="min-w-full border-collapse">
                                    <thead>
                                        <tr class="bg-gray-100">
                                            <th class="py-2 px-4 border">桶的范围</th>
                                            <th class="py-2 px-4 border">包含的元素</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.0-0.2)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.11</div>
                                                </div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.2-0.4)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.23</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.32</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.33</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.37</div>
                                                </div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.4-0.6)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.42</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.47</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.51</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.52</div>
                                                </div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.6-0.8)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <div class="w-16 h-16 flex items-center justify-center bg-blue-100 text-gray-800 font-medium rounded mx-1">0.78</div>
                                                </div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.8-1.0)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <span class="text-gray-400">(空)</span>
                                                </div>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- 步骤 3 -->
                        <div>
                            <h3 class="text-lg font-medium text-gray-800 mb-2">步骤 3：对每个桶内的元素排序</h3>
                            <p class="text-gray-700 mb-3">使用插入排序或其他排序算法对每个桶内的元素进行排序</p>
                            
                            <div class="overflow-x-auto mb-4">
                                <table class="min-w-full border-collapse">
                                    <thead>
                                        <tr class="bg-gray-100">
                                            <th class="py-2 px-4 border">桶的范围</th>
                                            <th class="py-2 px-4 border">排序后的元素</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.0-0.2)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.11</div>
                                                </div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.2-0.4)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.23</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.32</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.33</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.37</div>
                                                </div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.4-0.6)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.42</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.47</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.51</div>
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.52</div>
                                                </div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.6-0.8)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <div class="w-16 h-16 flex items-center justify-center bg-green-100 text-gray-800 font-medium rounded mx-1">0.78</div>
                                                </div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="py-2 px-4 border text-center">[0.8-1.0)</td>
                                            <td class="py-2 px-4 border">
                                                <div class="flex justify-center">
                                                    <span class="text-gray-400">(空)</span>
                                                </div>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- 步骤 4 -->
                        <div>
                            <h3 class="text-lg font-medium text-gray-800 mb-2">步骤 4：合并所有桶中的元素</h3>
                            <p class="text-gray-700 mb-3">按照桶的顺序，将各个桶内的元素合并得到最终的有序数组</p>
                            
                            <p class="text-gray-700 mb-3">最终排序结果：</p>
                            <div class="flex items-center justify-center space-x-2 my-4 flex-wrap">
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.11</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.23</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.32</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.33</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.37</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.42</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.47</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.51</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.52</div>
                                <div class="w-16 h-16 flex items-center justify-center bg-green-500 text-white font-medium rounded">0.78</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-gray-100 p-5 rounded-lg mt-6">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">桶排序过程总结</h3>
                        <ol class="list-decimal list-inside space-y-2 text-gray-700 ml-4">
                            <li>创建多个桶，每个桶表示特定的值范围</li>
                            <li>遍历原始数组，根据元素值将每个元素放入对应的桶中</li>
                            <li>对每个桶内的元素单独排序（使用合适的排序算法）</li>
                            <li>按照桶的顺序，将各个桶内的元素合并，得到最终的有序序列</li>
                        </ol>
                        <p class="text-gray-700 mt-3">当数据分布均匀时，每个桶内的元素数量接近相等，桶排序的效率最高。</p>
                    </div>
                </div>
            </section>
            
            <!-- 交互式可视化 -->
            <section id="visualization">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-chart-bar text-primary mr-3"></i>交互式可视化
                </h2>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <p class="text-gray-700 mb-4">以下是桶排序算法的交互式可视化演示，您可以生成新的随机数组并观察桶排序的执行过程。</p>
                    
                    <div class="flex flex-wrap gap-2 mb-4">
                        <button id="newArray" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
                            <i class="fas fa-random mr-2"></i>生成新数组
                        </button>
                        <button id="startSort" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition">
                            <i class="fas fa-play mr-2"></i>开始排序
                        </button>
                        <button id="pauseSort" class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition hidden">
                            <i class="fas fa-pause mr-2"></i>暂停排序
                        </button>
                        <button id="resetSort" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition">
                            <i class="fas fa-redo mr-2"></i>重置排序
                        </button>
                    </div>
                    
                    <div class="mb-4">
                        <label for="speed" class="block text-sm font-medium text-gray-700 mb-1">速度调节：</label>
                        <input type="range" id="speed" min="1" max="10" value="5" class="w-full md:w-1/2">
                    </div>
                    
                    <div class="flex flex-wrap items-center mb-4 text-sm">
                        <div class="flex items-center mr-4 mb-2">
                            <div class="w-4 h-4 bg-blue-400 mr-1"></div>
                            <span>原始数组</span>
                        </div>
                        <div class="flex items-center mr-4 mb-2">
                            <div class="w-4 h-4 bg-yellow-400 mr-1"></div>
                            <span>当前处理元素</span>
                        </div>
                        <div class="flex items-center mr-4 mb-2">
                            <div class="w-4 h-4 bg-green-400 mr-1"></div>
                            <span>已排序</span>
                        </div>
                        <div class="flex items-center mr-4 mb-2">
                            <div class="w-4 h-4 bg-purple-400 mr-1"></div>
                            <span>桶内元素</span>
                        </div>
                    </div>
                    
                    <div id="array-container" class="h-48 flex items-end justify-center border-b border-gray-300"></div>
                    
                    <div id="buckets-container" class="mt-6 border-t border-gray-300 pt-4">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">桶</h3>
                        <div id="buckets-grid" class="grid grid-cols-1 md:grid-cols-5 gap-4">
                            <!-- 桶将通过 JavaScript 动态生成 -->
                        </div>
                    </div>
                    
                    <div id="info-container" class="mt-4 text-gray-700">
                        <p id="current-step">准备开始桶排序...</p>
                    </div>
                </div>
            </section>
            
            <!-- 代码实现 -->
            <section id="implementation">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-code text-primary mr-3"></i>代码实现
                </h2>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <div class="mb-6">
                        <h3 class="text-xl font-medium text-gray-800 mb-3">C++ 实现</h3>
                        <pre class="bg-gray-800 text-white p-4 rounded-lg overflow-x-auto code-block"><code class="language-cpp">// 桶排序 - C++ 实现
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

// 桶排序函数，对浮点数范围为[0, 1)的数据进行排序
void bucketSort(std::vector&lt;double&gt;& arr) {
    const int n = arr.size();
    if (n <= 1) return;
    
    // 创建n个桶
    std::vector&lt;std::vector&lt;double&gt;&gt; buckets(n);
    
    // 将元素放入桶中
    for (int i = 0; i < n; i++) {
        int bucketIndex = n * arr[i]; // 计算桶索引
        buckets[bucketIndex].push_back(arr[i]);
    }
    
    // 对每个桶中的元素进行排序
    for (int i = 0; i < n; i++) {
        std::sort(buckets[i].begin(), buckets[i].end());
    }
    
    // 将桶中的元素按顺序放回原数组
    int index = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < buckets[i].size(); j++) {
            arr[index++] = buckets[i][j];
        }
    }
}

// 适用于任意范围数据的桶排序
void bucketSortGeneral(std::vector&lt;double&gt;& arr) {
    if (arr.empty()) return;
    
    // 找出最大值和最小值
    double min_val = *std::min_element(arr.begin(), arr.end());
    double max_val = *std::max_element(arr.begin(), arr.end());
    
    // 计算范围
    double range = max_val - min_val;
    if (range == 0) return; // 所有元素都相同
    
    // 确定桶的数量
    const int n = arr.size();
    int bucketCount = n;
    
    // 创建桶
    std::vector&lt;std::vector&lt;double&gt;&gt; buckets(bucketCount);
    
    // 将元素放入桶中
    for (double val : arr) {
        int bucketIndex = bucketCount * (val - min_val) / (range + 0.0000001);
        bucketIndex = std::min(bucketIndex, bucketCount - 1); // 防止索引越界
        buckets[bucketIndex].push_back(val);
    }
    
    // 对每个桶中的元素进行排序
    for (auto& bucket : buckets) {
        std::sort(bucket.begin(), bucket.end());
    }
    
    // 将桶中的元素按顺序放回原数组
    int index = 0;
    for (const auto& bucket : buckets) {
        for (double val : bucket) {
            arr[index++] = val;
        }
    }
}

// 整数桶排序示例
void bucketSortInt(std::vector&lt;int&gt;& arr, int bucketSize) {
    if (arr.empty()) return;
    
    // 找出最大值和最小值
    int min_val = *std::min_element(arr.begin(), arr.end());
    int max_val = *std::max_element(arr.begin(), arr.end());
    
    // 计算桶的数量
    int bucketCount = (max_val - min_val) / bucketSize + 1;
    std::vector&lt;std::vector&lt;int&gt;&gt; buckets(bucketCount);
    
    // 将元素放入桶中
    for (int val : arr) {
        int bucketIndex = (val - min_val) / bucketSize;
        buckets[bucketIndex].push_back(val);
    }
    
    // 对每个桶中的元素进行排序
    for (auto& bucket : buckets) {
        std::sort(bucket.begin(), bucket.end());
    }
    
    // 将桶中的元素按顺序放回原数组
    int index = 0;
    for (const auto& bucket : buckets) {
        for (int val : bucket) {
            arr[index++] = val;
        }
    }
}

// 示例使用
int main() {
    // 浮点数示例
    std::vector&lt;double&gt; arr = {0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51, 0.78, 0.11, 0.23};
    
    std::cout &lt;&lt; "原始数组: ";
    for (double num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    bucketSortGeneral(arr);
    
    std::cout &lt;&lt; "排序后: ";
    for (double num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    // 整数示例
    std::vector&lt;int&gt; arr_int = {29, 25, 3, 49, 9, 37, 21, 43};
    std::cout &lt;&lt; "整数数组: ";
    for (int num : arr_int) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    bucketSortInt(arr_int, 10); // 桶大小为10
    
    std::cout &lt;&lt; "排序后: ";
    for (int num : arr_int) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    
    return 0;
}</code></pre>
                    </div>
                    
                    <div>
                        <h3 class="text-xl font-medium text-gray-800 mb-3">优化技巧</h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700 ml-4">
                            <li><span class="font-medium">动态桶数量：</span>根据数据分布特点动态调整桶的数量，可以提高排序效率</li>
                            <li><span class="font-medium">并行处理：</span>各个桶之间相互独立，可以并行对桶内元素进行排序</li>
                            <li><span class="font-medium">桶内排序算法选择：</span>根据桶内数据量选择合适的排序算法，小数据量可用插入排序</li>
                            <li><span class="font-medium">数据预处理：</span>对数据进行预处理确保均匀分布，例如使用哈希函数改变分布</li>
                            <li><span class="font-medium">内存优化：</span>使用链表实现桶以减少内存开销和动态扩容成本</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- 时间复杂度分析 -->
            <section id="complexity">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-clock text-primary mr-3"></i>时间复杂度分析
                </h2>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div class="p-4 border border-green-200 rounded-lg bg-green-50">
                            <h3 class="text-lg font-medium text-gray-800 mb-2">最佳情况</h3>
                            <p class="text-2xl font-bold text-green-600 mb-2">O(n+k)</p>
                            <p class="text-gray-700 text-sm">当数据均匀分布在各个桶中，k为桶的数量</p>
                        </div>
                        <div class="p-4 border border-blue-200 rounded-lg bg-blue-50">
                            <h3 class="text-lg font-medium text-gray-800 mb-2">平均情况</h3>
                            <p class="text-2xl font-bold text-blue-600 mb-2">O(n+k)</p>
                            <p class="text-gray-700 text-sm">假设桶内排序使用比较排序，且数据分布较为均匀</p>
                        </div>
                        <div class="p-4 border border-red-200 rounded-lg bg-red-50">
                            <h3 class="text-lg font-medium text-gray-800 mb-2">最差情况</h3>
                            <p class="text-2xl font-bold text-red-600 mb-2">O(n²)</p>
                            <p class="text-gray-700 text-sm">当所有元素都被分配到同一个桶中</p>
                        </div>
                    </div>
                    
                    <div class="mt-6">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">空间复杂度</h3>
                        <p class="text-gray-700 mb-4">桶排序的空间复杂度主要取决于创建的桶的数量和存储的元素：</p>
                        <ul class="list-disc list-inside space-y-2 text-gray-700 ml-4">
                            <li><span class="font-medium">辅助空间：</span>O(n+k) - 需要额外的空间来存储桶和桶内元素</li>
                            <li><span class="font-medium">桶的数量：</span>通常为 O(n)，但可以根据实际情况调整</li>
                            <li><span class="font-medium">总空间复杂度：</span>O(n+k)</li>
                        </ul>
                    </div>
                    
                    <div class="mt-6 bg-gray-100 p-5 rounded-lg">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">影响桶排序性能的因素</h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700 ml-4">
                            <li><span class="font-medium">数据分布：</span>当数据均匀分布时，桶排序效率最高</li>
                            <li><span class="font-medium">桶的数量：</span>桶数量过少会导致单个桶中元素过多，桶数量过多会增加空间开销</li>
                            <li><span class="font-medium">桶内排序算法：</span>不同的桶内排序算法会影响整体性能</li>
                            <li><span class="font-medium">数据范围：</span>数据范围越大，桶的划分和管理越复杂</li>
                        </ul>
                    </div>
                </div>
            </section>
            
            <!-- 应用场景 -->
            <section id="applications">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-briefcase text-primary mr-3"></i>应用场景
                </h2>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <p class="text-gray-700 mb-4">桶排序在特定场景下表现优异，常用于以下应用：</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="border-l-4 border-primary pl-4">
                            <h3 class="text-lg font-medium text-gray-800 mb-2">均匀分布数据排序</h3>
                            <p class="text-gray-700">当输入数据服从均匀分布时，桶排序可以提供线性时间的排序性能</p>
                        </div>
                        <div class="border-l-4 border-primary pl-4">
                            <h3 class="text-lg font-medium text-gray-800 mb-2">外部排序</h3>
                            <p class="text-gray-700">处理大量数据时，可将数据分到多个文件（桶）中，再对每个文件单独排序</p>
                        </div>
                        <div class="border-l-4 border-primary pl-4">
                            <h3 class="text-lg font-medium text-gray-800 mb-2">数据库索引优化</h3>
                            <p class="text-gray-700">在设计数据库索引时，可以使用桶排序思想将记录分散存储</p>
                        </div>
                        <div class="border-l-4 border-primary pl-4">
                            <h3 class="text-lg font-medium text-gray-800 mb-2">浮点数排序</h3>
                            <p class="text-gray-700">对于浮点数区间内的数据，桶排序可以高效处理</p>
                        </div>
                    </div>
                    
                    <div class="mt-6 bg-gray-100 p-5 rounded-lg">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">经典应用案例</h3>
                        <div class="space-y-4">
                            <div>
                                <h4 class="font-medium text-gray-800 mb-2">1. 大规模日志数据排序</h4>
                                <p class="text-gray-700 mb-2">对服务器生成的大量日志数据按时间戳排序</p>
                                <div class="bg-white p-3 rounded shadow-sm">
                                    <p class="text-gray-700 text-sm">可以根据时间范围创建多个桶，每个桶负责特定时间段的日志，然后对每个桶内的日志单独排序，最后合并结果</p>
                                </div>
                            </div>
                            <div>
                                <h4 class="font-medium text-gray-800 mb-2">2. 网络数据包分类处理</h4>
                                <p class="text-gray-700 mb-2">对网络设备捕获的数据包按优先级或类型分类处理</p>
                                <div class="bg-white p-3 rounded shadow-sm">
                                    <p class="text-gray-700 text-sm">根据数据包的优先级创建不同的处理队列（桶），然后按优先级顺序处理这些队列</p>
                                </div>
                            </div>
                            <div>
                                <h4 class="font-medium text-gray-800 mb-2">3. 学生成绩分布统计</h4>
                                <p class="text-gray-700 mb-2">统计分析大量学生的成绩分布情况</p>
                                <div class="bg-white p-3 rounded shadow-sm">
                                    <p class="text-gray-700 text-sm">将成绩按分数段划分为多个区间（桶），例如0-10分、11-20分等，统计每个区间内的人数</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-6">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">练习题目</h3>
                        <ul class="list-disc list-inside space-y-3 text-gray-700 ml-4">
                            <li><a href="https://leetcode.cn/problems/sort-an-array/" target="_blank" class="text-blue-600 hover:underline">力扣 912. 排序数组</a> - 使用桶排序实现整数数组排序</li>
                            <li><a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" class="text-blue-600 hover:underline">力扣 347. 前 K 个高频元素</a> - 可以使用桶排序思想解决</li>
                            <li><a href="https://leetcode.cn/problems/h-index/" target="_blank" class="text-blue-600 hover:underline">力扣 274. H 指数</a> - 可以利用桶排序优化解法</li>
                        </ul>
                    </div>
                </div>
            </section>
            
            <!-- 与其他排序算法比较 -->
            <section id="comparison">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-balance-scale text-primary mr-3"></i>与其他排序算法比较
                </h2>
                <div class="bg-white p-6 rounded-lg shadow-md overflow-x-auto">
                    <table class="min-w-full bg-white">
                        <thead>
                            <tr>
                                <th class="py-3 px-4 border-b border-gray-200 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">算法</th>
                                <th class="py-3 px-4 border-b border-gray-200 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">最佳时间</th>
                                <th class="py-3 px-4 border-b border-gray-200 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">平均时间</th>
                                <th class="py-3 px-4 border-b border-gray-200 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">最差时间</th>
                                <th class="py-3 px-4 border-b border-gray-200 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">空间复杂度</th>
                                <th class="py-3 px-4 border-b border-gray-200 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">稳定性</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr class="bg-gray-100">
                                <td class="py-2 px-4 border-b border-gray-200 text-sm font-medium">桶排序</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n+k)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n+k)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n²)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n+k)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">稳定</td>
                            </tr>
                            <tr>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm font-medium">计数排序</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n+k)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n+k)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n+k)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n+k)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">稳定</td>
                            </tr>
                            <tr class="bg-gray-100">
                                <td class="py-2 px-4 border-b border-gray-200 text-sm font-medium">基数排序</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(nk)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(nk)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(nk)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n+k)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">稳定</td>
                            </tr>
                            <tr>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm font-medium">快速排序</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n log n)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n log n)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n²)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(log n)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">不稳定</td>
                            </tr>
                            <tr class="bg-gray-100">
                                <td class="py-2 px-4 border-b border-gray-200 text-sm font-medium">归并排序</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n log n)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n log n)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n log n)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">O(n)</td>
                                <td class="py-2 px-4 border-b border-gray-200 text-sm">稳定</td>
                            </tr>
                        </tbody>
                    </table>
                    <p class="mt-4 text-gray-700 text-sm">* n 是数组长度，k 是桶的数量或值的范围</p>
                </div>
            </section>
        </main>
        
        <!-- 页脚 -->
        <footer class="mt-10 p-6 bg-gray-800 text-white flex flex-col md:flex-row justify-between items-center">
            <div class="mb-4 md:mb-0">
                <p class="text-sm"> </p>
            </div>
            <div class="flex space-x-4">
                <a href="index.html" class="text-gray-300 hover:text-white transition-colors">首页</a>
                <a href="希尔排序.html" class="text-gray-300 hover:text-white transition-colors">希尔排序</a>
                <a href="锦标赛排序.html" class="text-gray-300 hover:text-white transition-colors">锦标赛排序</a>
                <a href="Tim 排序.html" class="text-gray-300 hover:text-white transition-colors">Tim 排序</a>
            </div>
            <button id="back-to-top" class="fixed right-6 bottom-6 p-3 bg-primary rounded-full shadow-lg text-white hidden">
                <i class="fas fa-arrow-up"></i>
            </button>
        </footer>
        
        <!-- ScrollReveal -->
        <script src="https://unpkg.com/scrollreveal"></script>
        
        <!-- Highlight.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
        
        <script>
            // ScrollReveal 初始化
            ScrollReveal().reveal('.section, h2, .bg-white', {
                distance: '50px',
                duration: 1000,
                delay: 200,
                easing: 'cubic-bezier(0.5, 0, 0, 1)'
            });
            
            // 回到顶部按钮
            const backToTopButton = document.getElementById('back-to-top');
            
            window.addEventListener('scroll', () => {
                if (window.pageYOffset > 300) {
                    backToTopButton.classList.remove('hidden');
                } else {
                    backToTopButton.classList.add('hidden');
                }
            });
            
            backToTopButton.addEventListener('click', () => {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
            
            // 桶排序交互式可视化
            document.addEventListener('DOMContentLoaded', function() {
                // 获取DOM元素
                const arrayContainer = document.getElementById('array-container');
                const bucketsGrid = document.getElementById('buckets-grid');
                const infoContainer = document.getElementById('current-step');
                const newArrayBtn = document.getElementById('newArray');
                const startSortBtn = document.getElementById('startSort');
                const pauseSortBtn = document.getElementById('pauseSort');
                const resetSortBtn = document.getElementById('resetSort');
                const speedSlider = document.getElementById('speed');
                
                // 初始化变量
                let array = [];
                const arraySize = 10;
                const minValue = 0;
                const maxValue = 1;
                let animationSpeed = 1000 / parseInt(speedSlider.value);
                let animations = [];
                let animationInterval;
                let isPaused = false;
                let currentAnimationStep = 0;
                
                // 创建新的随机数组
                function generateRandomArray() {
                    array = [];
                    for (let i = 0; i < arraySize; i++) {
                        // 生成0到1之间的随机浮点数，保留两位小数
                        array.push(parseFloat((Math.random() * (maxValue - minValue) + minValue).toFixed(2)));
                    }
                    renderArray(array);
                    resetAnimationState();
                    infoContainer.textContent = "准备开始桶排序...";
                    
                    // 清空桶显示
                    bucketsGrid.innerHTML = '';
                }
                
                // 渲染数组
                function renderArray(arr, currentIndex = -1, highlightIndices = [], sortedIndices = []) {
                    arrayContainer.innerHTML = '';
                    
                    arr.forEach((val, idx) => {
                        const bar = document.createElement('div');
                        const height = (val / maxValue) * 100;
                        
                        bar.style.height = `${height}%`;
                        bar.style.width = `${80 / arraySize}%`;
                        bar.style.margin = '0 0.2%';
                        bar.style.position = 'relative';
                        
                        // 设置颜色
                        if (idx === currentIndex) {
                            bar.style.backgroundColor = '#FBBF24'; // 当前处理元素
                        } else if (highlightIndices.includes(idx)) {
                            bar.style.backgroundColor = '#A78BFA'; // 特定元素高亮
                        } else if (sortedIndices.includes(idx)) {
                            bar.style.backgroundColor = '#10B981'; // 已排序
                        } else {
                            bar.style.backgroundColor = '#60A5FA'; // 默认
                        }
                        
                        // 添加数值标签
                        const label = document.createElement('div');
                        label.textContent = val;
                        label.style.position = 'absolute';
                        label.style.bottom = '-25px';
                        label.style.width = '100%';
                        label.style.textAlign = 'center';
                        label.style.fontSize = '12px';
                        bar.appendChild(label);
                        
                        arrayContainer.appendChild(bar);
                    });
                }
                
                // 渲染桶
                function renderBuckets(buckets, bucketRanges, currentBucketIndex = -1) {
                    bucketsGrid.innerHTML = '';
                    
                    for (let i = 0; i < buckets.length; i++) {
                        const bucketDiv = document.createElement('div');
                        bucketDiv.className = i === currentBucketIndex 
                            ? 'border-2 border-yellow-400 rounded-lg p-2'
                            : 'border rounded-lg p-2';
                        
                        // 桶标题
                        const bucketTitle = document.createElement('div');
                        bucketTitle.className = 'text-center font-medium mb-2 bg-gray-100 rounded py-1';
                        bucketTitle.textContent = `桶 ${i}: [${bucketRanges[i][0]}-${bucketRanges[i][1]})`;
                        bucketDiv.appendChild(bucketTitle);
                        
                        // 桶内元素
                        const bucketContent = document.createElement('div');
                        bucketContent.className = 'flex flex-wrap justify-center gap-1';
                        
                        if (buckets[i] && buckets[i].length > 0) {
                            buckets[i].sort((a, b) => a - b).forEach(num => {
                                const numBox = document.createElement('div');
                                numBox.className = 'px-2 py-1 bg-purple-100 rounded text-sm mb-1';
                                numBox.textContent = num;
                                bucketContent.appendChild(numBox);
                            });
                        } else {
                            const emptyMsg = document.createElement('div');
                            emptyMsg.className = 'text-gray-400 text-xs';
                            emptyMsg.textContent = '(空)';
                            bucketContent.appendChild(emptyMsg);
                        }
                        
                        bucketDiv.appendChild(bucketContent);
                        bucketsGrid.appendChild(bucketDiv);
                    }
                }
                
                // 生成桶排序的动画步骤
                function generateBucketSortAnimations(arr) {
                    const animations = [];
                    const n = arr.length;
                    const bucketCount = 5; // 使用5个桶
                    
                    if (n <= 1) {
                        return animations;
                    }
                    
                    // 复制数组以不修改原始数组
                    const arrCopy = [...arr];
                    
                    // 步骤1：确定范围和创建桶
                    const min = Math.min(...arrCopy);
                    const max = Math.max(...arrCopy);
                    const range = max - min;
                    const bucketSize = range / bucketCount;
                    
                    // 创建桶并计算每个桶的范围
                    const buckets = Array.from({ length: bucketCount }, () => []);
                    const bucketRanges = Array.from({ length: bucketCount }, (_, i) => [
                        +(min + i * bucketSize).toFixed(2),
                        +(min + (i + 1) * bucketSize).toFixed(2)
                    ]);
                    
                    animations.push({
                        step: '初始化',
                        array: [...arrCopy],
                        message: `创建${bucketCount}个桶，范围从${min.toFixed(2)}到${max.toFixed(2)}`,
                        buckets: buckets.map(bucket => [...bucket]),
                        bucketRanges
                    });
                    
                    // 步骤2：将元素分配到桶中
                    for (let i = 0; i < n; i++) {
                        const value = arrCopy[i];
                        // 计算桶索引
                        const bucketIndex = Math.min(
                            Math.floor((value - min) / bucketSize),
                            bucketCount - 1
                        );
                        
                        buckets[bucketIndex].push(value);
                        
                        animations.push({
                            step: '分配元素',
                            array: [...arrCopy],
                            currentIndex: i,
                            message: `将元素 ${value} 放入桶 ${bucketIndex}`,
                            buckets: buckets.map(bucket => [...bucket]),
                            bucketRanges,
                            currentBucketIndex: bucketIndex
                        });
                    }
                    
                    animations.push({
                        step: '分配完成',
                        array: [...arrCopy],
                        message: '所有元素分配到桶中完成',
                        buckets: buckets.map(bucket => [...bucket]),
                        bucketRanges
                    });
                    
                    // 步骤3：对每个桶内的元素排序
                    for (let i = 0; i < bucketCount; i++) {
                        if (buckets[i].length > 0) {
                            animations.push({
                                step: '桶内排序',
                                array: [...arrCopy],
                                message: `对桶 ${i} 内的元素排序`,
                                buckets: buckets.map(bucket => [...bucket]),
                                bucketRanges,
                                currentBucketIndex: i
                            });
                            
                            buckets[i].sort((a, b) => a - b);
                            
                            animations.push({
                                step: '桶内排序完成',
                                array: [...arrCopy],
                                message: `桶 ${i} 内元素排序完成`,
                                buckets: buckets.map(bucket => [...bucket]),
                                bucketRanges,
                                currentBucketIndex: i
                            });
                        }
                    }
                    
                    // 步骤4：将桶中的元素合并回原数组
                    let index = 0;
                    const sortedArray = [...arrCopy];
                    
                    for (let i = 0; i < bucketCount; i++) {
                        if (buckets[i].length > 0) {
                            animations.push({
                                step: '合并桶',
                                array: [...sortedArray],
                                message: `合并桶 ${i} 中的元素`,
                                buckets: buckets.map(bucket => [...bucket]),
                                bucketRanges,
                                currentBucketIndex: i
                            });
                            
                            for (let j = 0; j < buckets[i].length; j++) {
                                sortedArray[index] = buckets[i][j];
                                
                                animations.push({
                                    step: '合并元素',
                                    array: [...sortedArray],
                                    message: `将桶 ${i} 中的元素 ${buckets[i][j]} 放回位置 ${index}`,
                                    buckets: buckets.map(bucket => [...bucket]),
                                    bucketRanges,
                                    currentBucketIndex: i,
                                    highlightIndices: [index]
                                });
                                
                                index++;
                            }
                        }
                    }
                    
                    animations.push({
                        step: '排序完成',
                        array: [...sortedArray],
                        message: '桶排序完成!',
                        buckets: buckets.map(bucket => [...bucket]),
                        bucketRanges,
                        sortedIndices: Array.from({ length: n }, (_, i) => i)
                    });
                    
                    return animations;
                }
                
                // 开始排序动画
                function startSortAnimation() {
                    if (animations.length === 0 || currentAnimationStep >= animations.length) {
                        // 为当前数组生成动画
                        animations = generateBucketSortAnimations([...array]);
                        currentAnimationStep = 0;
                    }
                    
                    startSortBtn.classList.add('hidden');
                    pauseSortBtn.classList.remove('hidden');
                    isPaused = false;
                    
                    animationInterval = setInterval(() => {
                        if (currentAnimationStep < animations.length) {
                            const step = animations[currentAnimationStep];
                            
                            renderArray(
                                step.array, 
                                step.currentIndex, 
                                step.highlightIndices || [], 
                                step.sortedIndices || []
                            );
                            
                            if (step.buckets) {
                                renderBuckets(step.buckets, step.bucketRanges, step.currentBucketIndex);
                            }
                            
                            infoContainer.textContent = step.message;
                            currentAnimationStep++;
                        } else {
                            clearInterval(animationInterval);
                            infoContainer.textContent = "排序完成!";
                            pauseSortBtn.classList.add('hidden');
                            startSortBtn.classList.remove('hidden');
                            
                            // 显示全部排序完成
                            if (animations.length > 0) {
                                const finalStep = animations[animations.length - 1];
                                renderArray(finalStep.array, -1, [], Array.from({length: finalStep.array.length}, (_, i) => i));
                            }
                        }
                    }, animationSpeed);
                }
                
                // 暂停排序动画
                function pauseSortAnimation() {
                    clearInterval(animationInterval);
                    isPaused = true;
                    pauseSortBtn.classList.add('hidden');
                    startSortBtn.classList.remove('hidden');
                }
                
                // 重置动画状态
                function resetAnimationState() {
                    clearInterval(animationInterval);
                    animations = [];
                    currentAnimationStep = 0;
                    isPaused = false;
                    pauseSortBtn.classList.add('hidden');
                    startSortBtn.classList.remove('hidden');
                }
                
                // 事件监听器
                newArrayBtn.addEventListener('click', generateRandomArray);
                startSortBtn.addEventListener('click', startSortAnimation);
                pauseSortBtn.addEventListener('click', pauseSortAnimation);
                resetSortBtn.addEventListener('click', () => {
                    resetAnimationState();
                    renderArray(array);
                    bucketsGrid.innerHTML = '';
                    infoContainer.textContent = "排序已重置";
                });
                
                speedSlider.addEventListener('input', function() {
                    animationSpeed = 1000 / parseInt(this.value);
                    if (!isPaused && animationInterval) {
                        clearInterval(animationInterval);
                        startSortAnimation();
                    }
                });
                
                // 初始化
                generateRandomArray();
            });
        </script>
    </div>
</body>
</html> 