<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>算法复杂度分析</title>
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            light: '#a5f3fc',
                            DEFAULT: '#06b6d4',
                            dark: '#0891b2',
                        },
                        secondary: {
                            light: '#c7d2fe',
                            DEFAULT: '#818cf8',
                            dark: '#6366f1',
                        },
                        codeBlock: '#1e293b',
                    },
                    fontFamily: {
                        sans: ['Poppins', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        .card-hover {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card-hover:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(6, 182, 212, 0.1), 0 10px 10px -5px rgba(6, 182, 212, 0.04);
        }
        .code-block::-webkit-scrollbar {
            height: 8px;
        }
        .code-block::-webkit-scrollbar-thumb {
            background-color: #06b6d4;
            border-radius: 4px;
        }
        .code-block::-webkit-scrollbar-track {
            background-color: #e2e8f0;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="min-h-screen max-w-6xl mx-auto px-8 py-10">
        <!-- Header -->
        <header class="mb-12 text-center">
            <div class="inline-block px-3 py-1 bg-primary-light text-primary-dark rounded-full text-sm font-medium mb-4">
                算法基础
            </div>
            <h1 class="text-4xl font-bold text-gray-800 mb-4">算法复杂度分析</h1>
            <p class="text-lg text-gray-600 max-w-3xl mx-auto">理解算法效率的度量：时间复杂度与空间复杂度</p>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 复杂度概述 -->
            <section class="mb-12 bg-white rounded-xl p-8 shadow-md card-hover">
                <div class="flex items-center mb-6">
                    <div class="bg-primary-light p-3 rounded-lg mr-4">
                        <i class="fas fa-tachometer-alt text-primary-dark text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">复杂度的概念</h2>
                </div>
                <p class="text-gray-700 mb-4">
                    算法复杂度是衡量算法效率的重要指标，主要分为<strong>时间复杂度</strong>和<strong>空间复杂度</strong>两种。时间复杂度表示算法运行时间随输入规模增长的关系，空间复杂度表示算法内存占用随输入规模增长的关系。
                </p>
                <p class="text-gray-700 mb-4">
                    复杂度通常用大O表示法（O-notation）来描述算法的上界，表示算法在最坏情况下的性能。
                </p>
                <div class="bg-blue-50 border-l-4 border-blue-500 p-4 rounded-r mb-4">
                    <p class="text-blue-700">
                        当我们讨论算法复杂度时，我们关注的是算法效率随输入规模增长的<strong>渐近行为</strong>，而不是具体的常数时间。
                    </p>
                </div>
            </section>

            <!-- 时间复杂度 -->
            <section class="mb-12 bg-white rounded-xl p-8 shadow-md card-hover">
                <div class="flex items-center mb-6">
                    <div class="bg-primary-light p-3 rounded-lg mr-4">
                        <i class="fas fa-clock text-primary-dark text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">时间复杂度</h2>
                </div>
                <p class="text-gray-700 mb-4">
                    时间复杂度用于衡量算法执行所需的时间与输入规模之间的关系。通常以算法中基本操作的执行次数作为时间复杂度的度量。
                </p>
                
                <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">常见的时间复杂度</h3>
                <div class="overflow-x-auto mb-6">
                    <table class="min-w-full bg-white border border-gray-200">
                        <thead>
                            <tr class="bg-gray-100">
                                <th class="py-3 px-4 border-b text-left">复杂度</th>
                                <th class="py-3 px-4 border-b text-left">名称</th>
                                <th class="py-3 px-4 border-b text-left">示例</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="py-3 px-4 border-b font-mono">O(1)</td>
                                <td class="py-3 px-4 border-b">常数时间</td>
                                <td class="py-3 px-4 border-b">数组索引访问、哈希表操作</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-mono">O(log n)</td>
                                <td class="py-3 px-4 border-b">对数时间</td>
                                <td class="py-3 px-4 border-b">二分查找、平衡二叉树操作</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-mono">O(n)</td>
                                <td class="py-3 px-4 border-b">线性时间</td>
                                <td class="py-3 px-4 border-b">遍历数组、线性搜索</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-mono">O(n log n)</td>
                                <td class="py-3 px-4 border-b">线性对数时间</td>
                                <td class="py-3 px-4 border-b">归并排序、快速排序</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-mono">O(n²)</td>
                                <td class="py-3 px-4 border-b">平方时间</td>
                                <td class="py-3 px-4 border-b">冒泡排序、插入排序</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-mono">O(2ⁿ)</td>
                                <td class="py-3 px-4 border-b">指数时间</td>
                                <td class="py-3 px-4 border-b">递归斐波那契数列、子集生成</td>
                            </tr>
                            <tr>
                                <td class="py-3 px-4 border-b font-mono">O(n!)</td>
                                <td class="py-3 px-4 border-b">阶乘时间</td>
                                <td class="py-3 px-4 border-b">旅行商问题的暴力解法</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">时间复杂度分析示例</h3>
                <div class="rounded-lg bg-codeBlock p-5 overflow-x-auto code-block mb-4">
                    <pre class="text-gray-100 font-mono">
// O(1) 复杂度
void constant(int n) {
    int x = 5;
    int y = 10;
    printf("%d\n", x + y);
}

// O(n) 复杂度
void linear(int n) {
    for (int i = 0; i < n; i++) {
        printf("%d\n", i);
    }
}

// O(n²) 复杂度
void quadratic(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%d,%d\n", i, j);
        }
    }
}

// O(log n) 复杂度
int binarySearch(int arr[], int l, int r, int x) {
    while (l <= r) {
        int m = l + (r - l) / 2;
        if (arr[m] == x) return m;
        if (arr[m] < x) l = m + 1;
        else r = m - 1;
    }
    return -1;
}</pre>
                </div>
            </section>

            <!-- 空间复杂度 -->
            <section class="mb-12 bg-white rounded-xl p-8 shadow-md card-hover">
                <div class="flex items-center mb-6">
                    <div class="bg-primary-light p-3 rounded-lg mr-4">
                        <i class="fas fa-memory text-primary-dark text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">空间复杂度</h2>
                </div>
                <p class="text-gray-700 mb-4">
                    空间复杂度衡量算法在执行过程中占用的存储空间与输入规模之间的关系。包括算法使用的辅助空间和输入数据所占的空间。
                </p>
                
                <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">常见的空间复杂度</h3>
                <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4 pl-4">
                    <li><span class="font-mono font-bold">O(1)</span> - 常数空间：算法所需的额外空间不随输入规模变化</li>
                    <li><span class="font-mono font-bold">O(n)</span> - 线性空间：额外空间与输入规模成正比</li>
                    <li><span class="font-mono font-bold">O(n²)</span> - 平方空间：常见于需要二维数组的算法</li>
                </ul>

                <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">空间复杂度分析示例</h3>
                <div class="rounded-lg bg-codeBlock p-5 overflow-x-auto code-block mb-4">
                    <pre class="text-gray-100 font-mono">
// O(1) 空间复杂度
int sum(int arr[], int n) {
    int result = 0;  // 常数空间
    for (int i = 0; i < n; i++) {
        result += arr[i];
    }
    return result;
}

// O(n) 空间复杂度
int[] duplicate(int arr[], int n) {
    int[] copy = new int[n];  // 线性空间
    for (int i = 0; i < n; i++) {
        copy[i] = arr[i];
    }
    return copy;
}

// O(n²) 空间复杂度
int[][] createMatrix(int n) {
    int[][] matrix = new int[n][n];  // 平方空间
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            matrix[i][j] = i * j;
        }
    }
    return matrix;
}</pre>
                </div>
            </section>

            <!-- 复杂度分析技巧 -->
            <section class="mb-12 bg-white rounded-xl p-8 shadow-md card-hover">
                <div class="flex items-center mb-6">
                    <div class="bg-primary-light p-3 rounded-lg mr-4">
                        <i class="fas fa-tools text-primary-dark text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">复杂度分析技巧</h2>
                </div>
                <p class="text-gray-700 mb-4">
                    分析算法复杂度需要考虑算法在不同输入规模下的渐近行为，忽略常数因子和低阶项。以下是一些常用的分析技巧：
                </p>
                
                <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">基本规则</h3>
                <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4 pl-4">
                    <li><strong>忽略常数因子</strong>：O(2n) 等价于 O(n)</li>
                    <li><strong>只保留最高阶项</strong>：O(n² + n) 等价于 O(n²)</li>
                    <li><strong>循环嵌套分析</strong>：嵌套循环通常导致复杂度相乘</li>
                    <li><strong>递归算法分析</strong>：通常需要使用递推关系或主定理</li>
                </ul>

                <h3 class="text-xl font-semibold text-gray-800 mt-6 mb-3">不同算法结构的复杂度</h3>
                <ul class="list-disc list-inside space-y-2 text-gray-700 mb-4 pl-4">
                    <li><strong>顺序语句</strong>：取最大复杂度，如 O(1) + O(n) = O(n)</li>
                    <li><strong>条件语句</strong>：取分支中的最大复杂度</li>
                    <li><strong>循环语句</strong>：循环次数 × 循环体复杂度</li>
                    <li><strong>嵌套循环</strong>：各层循环次数的乘积</li>
                </ul>

                <div class="bg-yellow-50 border-l-4 border-yellow-500 p-4 rounded-r">
                    <p class="text-yellow-700">
                        <strong>注意：</strong>在实际应用中，常数因子虽然在渐近分析中被忽略，但在输入规模较小时可能对性能有显著影响。
                    </p>
                </div>
            </section>

            <!-- 复杂度优化 -->
            <section class="bg-white rounded-xl p-8 shadow-md card-hover">
                <div class="flex items-center mb-6">
                    <div class="bg-primary-light p-3 rounded-lg mr-4">
                        <i class="fas fa-rocket text-primary-dark text-xl"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800">复杂度优化</h2>
                </div>
                <p class="text-gray-700 mb-4">
                    算法复杂度优化是提高算法效率的关键。以下是一些常见的优化策略：
                </p>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-50 p-5 rounded-lg">
                        <h3 class="text-lg font-semibold text-gray-800 mb-3">时间复杂度优化</h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700 pl-4">
                            <li>使用更高效的数据结构（如哈希表替代数组）</li>
                            <li>避免重复计算（如动态规划中的记忆化）</li>
                            <li>使用分治策略（如二分查找代替线性搜索）</li>
                            <li>预处理和缓存（如排序后再查找）</li>
                        </ul>
                    </div>
                    
                    <div class="bg-gray-50 p-5 rounded-lg">
                        <h3 class="text-lg font-semibold text-gray-800 mb-3">空间复杂度优化</h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700 pl-4">
                            <li>原地算法（in-place algorithm）</li>
                            <li>重用已分配的空间</li>
                            <li>使用迭代代替递归（避免调用栈开销）</li>
                            <li>压缩数据结构（如位图Bitmap）</li>
                        </ul>
                    </div>
                </div>

                <p class="text-gray-700 mb-4">
                    在实际应用中，需要根据具体场景在时间复杂度和空间复杂度之间找到平衡，有时可以通过牺牲一定的空间来换取时间效率的提升，反之亦然。
                </p>
            </section>
        </main>

        <!-- Footer -->
        <footer class="mt-16 text-center text-gray-500 text-sm">
            <div class="flex justify-center mt-6 space-x-4">
                <a href="简介.html" class="text-primary hover:text-primary-dark transition-colors duration-300">
                    <i class="fas fa-home mr-1"></i>首页
                </a>
                <a href="均摊复杂度.html" class="text-primary hover:text-primary-dark transition-colors duration-300">
                    均摊复杂度<i class="fas fa-arrow-right ml-1"></i>
                </a>
            </div>
        </footer>
    </div>

    <!-- Back to top button -->
    <button id="backToTop" class="fixed bottom-6 right-6 bg-primary hover:bg-primary-dark text-white rounded-full p-3 shadow-lg transition-all duration-300 opacity-0 invisible">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- JavaScript for Back to top button -->
    <script>
        const backToTop = document.getElementById('backToTop');
        
        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                backToTop.classList.remove('opacity-0', 'invisible');
                backToTop.classList.add('opacity-100', 'visible');
            } else {
                backToTop.classList.remove('opacity-100', 'visible');
                backToTop.classList.add('opacity-0', 'invisible');
            }
        });
        
        backToTop.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    </script>
    <!-- Simple ScrollReveal effect -->
    <script src="https://unpkg.com/scrollreveal"></script>
    <script>
        ScrollReveal().reveal('section', { 
            delay: 200,
            distance: '20px',
            origin: 'bottom',
            duration: 800,
            easing: 'ease-in-out'
        });
    </script>
</body>
</html> 