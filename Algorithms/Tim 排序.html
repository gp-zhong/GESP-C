<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tim 排序</title>
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            light: '#a5f3fc',
                            DEFAULT: '#06b6d4',
                            dark: '#0891b2',
                        },
                        secondary: {
                            light: '#c7d2fe',
                            DEFAULT: '#818cf8',
                            dark: '#6366f1',
                        },
                        codeBlock: '#1e293b',
                    },
                    fontFamily: {
                        sans: ['Poppins', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        :root {
            --primary: #4F46E5;
            --primary-dark: #4338CA;
            --primary-light: #818CF8;
            --blue-500: #3B82F6;
            --green-500: #10B981;
            --purple-500: #8B5CF6;
            --red-500: #EF4444;
            --orange-500: #F97316;
            --indigo-500: #6366F1;
            --yellow-500: #F59E0B;
            --pink-500: #EC4899;
            --gray-300: #D1D5DB;
            --purple-400: #A78BFA;
        }
        
        /* 动画效果 */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }
        .animate-pulse {
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        /* 淡入效果 */
        .opacity-0 {
            opacity: 0;
        }
        .opacity-100 {
            opacity: 1;
        }
        
        .card-hover {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card-hover:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(6, 182, 212, 0.1), 0 10px 10px -5px rgba(6, 182, 212, 0.04);
        }
        .code-block::-webkit-scrollbar {
            height: 8px;
        }
        .code-block::-webkit-scrollbar-thumb {
            background-color: #06b6d4;
            border-radius: 4px;
        }
        .code-block::-webkit-scrollbar-track {
            background-color: #e2e8f0;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="min-h-screen max-w-6xl mx-auto px-8 py-10">
        <!-- Header -->
        <header class="mb-12 text-center">
            <div class="inline-block px-3 py-1 bg-primary-light text-primary-dark rounded-full text-sm font-medium mb-4">
                算法基础
            </div>
            <h1 class="text-4xl font-bold text-gray-800 mb-4">Tim 排序</h1>
            <p class="text-lg text-gray-600 max-w-3xl mx-auto">一种混合稳定的排序算法，结合了归并排序和插入排序的优点</p>
        </header>

        <!-- Main Content -->
        <main class="space-y-12">
            <!-- 算法概述 -->
            <section class="section bg-white rounded-xl p-8 shadow-md">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <i class="fas fa-info-circle text-primary mr-3"></i>算法概述
                </h2>
                <div class="space-y-4">
                    <p class="text-gray-700">Tim 排序（Timsort）是一种混合稳定的排序算法，由 Tim Peters 于2002年为 Python 编程语言创建。它结合了合并排序和插入排序的优点，在各种现实世界的数据上都表现出色。Tim 排序已被 Java、Android、Swift 等多种主流编程语言采用为默认的排序算法。</p>
                    <p class="text-gray-700">该算法被设计用于处理真实世界的数据，这些数据通常包含部分有序序列（称为"自然顺序性"）。Tim 排序能有效利用这些预先存在的顺序，显著提高排序效率。</p>
                    
                    <div class="bg-gray-50 p-4 rounded-lg border-l-4 border-primary mt-4">
                        <h3 class="font-semibold text-gray-800 mb-2">核心思想</h3>
                        <p class="text-gray-700">Tim 排序的核心思想是将输入数组分成多个已排序的块（称为"run"），然后使用插入排序算法对小块进行排序，最后使用归并排序将这些块合并在一起。它针对各种输入模式进行了高度优化，同时保持了归并排序的优良稳定性和O(n log n)的最坏情况性能。</p>
                    </div>
                    
                    <div class="mt-4 flex flex-col md:flex-row gap-4">
                        <div class="flex-1 bg-gray-50 p-4 rounded-lg">
                            <h3 class="font-semibold text-gray-800 mb-2">排序类型</h3>
                            <ul class="list-disc list-inside">
                                <li>混合排序（结合插入排序和归并排序）</li>
                                <li>比较排序</li>
                                <li>自适应排序</li>
                                <li>稳定排序</li>
                                <li>非原地排序（但实现上尽量减少临时空间使用）</li>
                            </ul>
                        </div>
                        <div class="flex-1 bg-gray-50 p-4 rounded-lg">
                            <h3 class="font-semibold text-gray-800 mb-2">主要特点</h3>
                            <ul class="list-disc list-inside">
                                <li>利用数据的自然顺序性</li>
                                <li>对小数组使用插入排序</li>
                                <li>维护排序稳定性</li>
                                <li>针对真实数据模式进行了优化</li>
                                <li>采用galloping模式加速归并过程</li>
                                <li>最坏情况保证O(n log n)的时间复杂度</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 算法工作原理 -->
            <section class="section bg-white rounded-xl p-8 shadow-md">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <i class="fas fa-cogs text-primary mr-3"></i>工作原理
                </h2>
                <div class="space-y-4">
                    <p class="text-gray-700">Tim 排序的工作原理相对复杂，它结合了多种技术和优化策略，主要分为以下几个步骤：</p>
                    
                    <ol class="list-decimal list-inside space-y-3 text-gray-700 ml-4">
                        <li><span class="font-semibold">划分runs</span>：扫描原始数组，根据数据的自然顺序性，将数组划分为多个有序或近似有序的子序列（称为runs）。一个run可以是递增或严格递减的序列（递减序列会被反转为递增序列）。</li>
                        <li><span class="font-semibold">确定最小run长度</span>：根据数组总长度计算一个最小run长度（minrun），通常在16到32之间。这样做可以使归并步骤的效率更高。</li>
                        <li><span class="font-semibold">扩展runs至minrun</span>：如果某个run的长度小于minrun，则使用插入排序将其扩展到minrun长度。</li>
                        <li><span class="font-semibold">维护runs栈</span>：使用一个栈来保存已处理的runs，确保栈中的runs长度满足特定的约束条件（通常是递减的斐波那契数列）。</li>
                        <li><span class="font-semibold">合并相邻runs</span>：根据特定规则（如尽量保持大小平衡）合并相邻的runs，直到所有runs都被合并为一个完整的有序序列。合并过程使用优化的归并算法，包括galloping模式。</li>
                    </ol>

                    <div class="mt-6">
                        <h3 class="font-semibold text-gray-800 mb-4">核心组件详解：</h3>
                        
                        <div class="mt-4 bg-gray-50 p-4 rounded-lg">
                            <h4 class="font-semibold text-blue-700 mb-2">1. Run的识别与构建</h4>
                            <p class="text-gray-700">Tim 排序首先在数组中寻找严格递增（或严格递减）的子序列，这些子序列是自然出现的有序片段。如果序列长度小于minrun（根据数组长度计算的一个优化值），则使用二分插入排序将其扩展至minrun长度。</p>
                            
                            <div class="my-4 flex justify-center">
                                <div class="bg-white p-4 rounded-lg shadow-sm max-w-lg">
                                    <div class="flex flex-wrap justify-center gap-2 mb-3">
                                        <div class="bg-blue-100 px-3 py-1 rounded-lg text-blue-900 flex items-center">7</div>
                                        <div class="bg-blue-100 px-3 py-1 rounded-lg text-blue-900 flex items-center">8</div>
                                        <div class="bg-blue-100 px-3 py-1 rounded-lg text-blue-900 flex items-center">9</div>
                                        <div class="bg-gray-100 px-3 py-1 rounded-lg text-gray-600 flex items-center">2</div>
                                        <div class="bg-gray-100 px-3 py-1 rounded-lg text-gray-600 flex items-center">3</div>
                                        <div class="bg-gray-100 px-3 py-1 rounded-lg text-gray-600 flex items-center">4</div>
                                        <div class="bg-gray-100 px-3 py-1 rounded-lg text-gray-600 flex items-center">5</div>
                                        <div class="bg-red-100 px-3 py-1 rounded-lg text-red-900 flex items-center">12</div>
                                        <div class="bg-red-100 px-3 py-1 rounded-lg text-red-900 flex items-center">6</div>
                                        <div class="bg-red-100 px-3 py-1 rounded-lg text-red-900 flex items-center">1</div>
                                    </div>
                                    <p class="text-xs text-gray-500 text-center">识别出的三个不同的runs，每个颜色代表一个run</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mt-4 bg-gray-50 p-4 rounded-lg">
                            <h4 class="font-semibold text-blue-700 mb-2">2. 归并策略（Merging Strategy）</h4>
                            <p class="text-gray-700">Tim 排序使用一个精心设计的归并策略来合并已排序的runs。它维护一个runs栈，并根据以下规则决定何时进行合并：</p>
                            <ul class="list-disc list-inside mt-2 text-gray-700">
                                <li>X > Y + Z</li>
                                <li>Y > Z</li>
                            </ul>
                            <p class="text-gray-700 mt-2">其中X、Y、Z是栈顶的三个runs的长度。当这些条件被违反时，将较小的相邻runs合并，以维持栈的平衡。</p>
                            
                            <div class="my-4 flex justify-center">
                                <div class="bg-white p-4 rounded-lg shadow-sm">
                                    <svg width="320" height="200" viewBox="0 0 320 200">
                                        <!-- 栈底部 -->
                                        <rect x="100" y="170" width="120" height="20" fill="#e5e7eb" stroke="#9ca3af" />
                                        <text x="160" y="185" text-anchor="middle" font-size="14">栈底</text>
                                        
                                        <!-- Run Z -->
                                        <rect x="100" y="140" width="120" height="30" fill="#dbeafe" stroke="#3b82f6" />
                                        <text x="160" y="160" text-anchor="middle" font-size="14">Run Z (长度 50)</text>
                                        
                                        <!-- Run Y -->
                                        <rect x="100" y="110" width="120" height="30" fill="#bbf7d0" stroke="#22c55e" />
                                        <text x="160" y="130" text-anchor="middle" font-size="14">Run Y (长度 70)</text>
                                        
                                        <!-- Run X -->
                                        <rect x="100" y="80" width="120" height="30" fill="#fed7aa" stroke="#f97316" />
                                        <text x="160" y="100" text-anchor="middle" font-size="14">Run X (长度 140)</text>
                                        
                                        <!-- 规则文本 -->
                                        <text x="160" y="40" text-anchor="middle" font-size="14" font-weight="bold">合并规则</text>
                                        <text x="160" y="60" text-anchor="middle" font-size="12">X > Y + Z (140 > 70 + 50) ✓</text>
                                        <text x="160" y="75" text-anchor="middle" font-size="12">Y > Z (70 > 50) ✓</text>
                                    </svg>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mt-4 bg-gray-50 p-4 rounded-lg">
                            <h4 class="font-semibold text-blue-700 mb-2">3. Galloping Mode（飞奔模式）</h4>
                            <p class="text-gray-700">Tim 排序在归并过程中使用了一种名为"galloping"的优化技术。当连续多次从同一个数组中选择元素时，算法会切换到galloping模式：使用二分查找快速定位元素的正确位置，这在处理有很多重复元素或高度结构化的数据时非常有效。</p>
                            
                            <div class="my-4 flex justify-center">
                                <div class="bg-white p-4 rounded-lg shadow-sm max-w-lg">
                                    <p class="text-sm text-gray-700 mb-2">普通模式下逐个比较：</p>
                                    <div class="flex flex-wrap justify-center gap-2 mb-4">
                                        <div class="bg-blue-100 px-3 py-1 rounded-lg text-blue-900 flex items-center">1</div>
                                        <div class="bg-blue-100 px-3 py-1 rounded-lg text-blue-900 flex items-center">3</div>
                                        <div class="bg-blue-100 px-3 py-1 rounded-lg text-blue-900 flex items-center">5</div>
                                        <div class="bg-blue-100 px-3 py-1 rounded-lg text-blue-900 flex items-center">7</div>
                                        <div class="bg-blue-100 px-3 py-1 rounded-lg text-blue-900 flex items-center">9</div>
                                    </div>
                                    
                                    <div class="flex justify-center mb-4">
                                        <i class="fas fa-arrows-alt-v text-gray-400"></i>
                                    </div>
                                    
                                    <p class="text-sm text-gray-700 mb-2">Galloping模式下使用二分查找：</p>
                                    <div class="flex flex-wrap justify-center gap-2">
                                        <div class="bg-green-100 px-3 py-1 rounded-lg text-green-900 flex items-center">2</div>
                                        <div class="bg-green-100 px-3 py-1 rounded-lg text-green-900 flex items-center">4</div>
                                        <div class="bg-green-100 px-3 py-1 rounded-lg text-green-900 flex items-center">6</div>
                                        <div class="bg-green-100 px-3 py-1 rounded-lg text-green-900 flex items-center">8</div>
                                        <div class="bg-green-100 px-3 py-1 rounded-lg text-green-900 flex items-center">10</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
                            <div class="bg-blue-50 p-4 rounded-lg">
                                <h4 class="font-semibold text-blue-800 mb-2">为什么使用最小run长度</h4>
                                <p class="text-gray-700">设定一个最小run长度（通常是16到32之间）可以确保：</p>
                                <ol class="list-decimal list-inside mt-2 text-gray-700">
                                    <li>插入排序对小型数组高效运行</li>
                                    <li>归并排序应用于较大的已排序块</li>
                                    <li>最终的归并树更加平衡</li>
                                </ol>
                            </div>
                            
                            <div class="bg-yellow-50 p-4 rounded-lg">
                                <h4 class="font-semibold text-yellow-800 mb-2">针对真实数据的优化</h4>
                                <p class="text-gray-700">Tim 排序针对真实世界的数据模式进行了多项优化：</p>
                                <ul class="list-disc list-inside mt-2 text-gray-700">
                                    <li>识别并利用预先存在的顺序</li>
                                    <li>对近乎有序的数据效率极高</li>
                                    <li>通过自适应技术处理不同的数据分布</li>
                                    <li>优化临时空间的使用</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 代码实现 -->
            <section class="section bg-white rounded-xl p-8 shadow-md">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <i class="fas fa-code text-primary mr-3"></i>代码实现
                </h2>
                
                <div class="space-y-6">
                    <p class="text-gray-700">以下是Tim排序的C++实现。为了清晰起见，我们将分步骤展示实现的关键部分：</p>
                    
                    <div class="bg-codeBlock rounded-lg overflow-hidden">
                        <div class="flex justify-between items-center px-4 py-2 bg-gray-700 text-white">
                            <span class="font-mono text-sm">C++ 实现</span>
                            <div class="flex space-x-2">
                                <div class="w-3 h-3 rounded-full bg-red-500"></div>
                                <div class="w-3 h-3 rounded-full bg-yellow-500"></div>
                                <div class="w-3 h-3 rounded-full bg-green-500"></div>
                            </div>
                        </div>
                        <pre class="code-block p-4 text-white font-mono text-sm overflow-x-auto"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;limits&gt;

// Tim排序的C++实现
class TimSort {
private:
    static const int MIN_MERGE = 32;  // 最小归并长度
    static const int MIN_GALLOP = 7;  // 开始galloping模式的最小阈值
    
    std::vector&lt;int&gt;& arr;
    std::vector&lt;int&gt; tmp;  // 临时数组，用于归并
    int minRun;            // 计算出的最小run长度
    
    // 计算最小run长度
    static int computeMinRun(int n) {
        int r = 0;
        while (n >= MIN_MERGE) {
            r |= (n & 1);
            n >>= 1;
        }
        return n + r;
    }
    
    // 二分插入排序：用于小数组排序
    void binaryInsertionSort(int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            int temp = arr[i];
            int j = i - 1;
            
            // 使用二分查找找到插入位置
            int loc = std::lower_bound(arr.begin() + left, arr.begin() + i, temp) - arr.begin();
            
            // 将元素后移
            while (j >= loc) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[loc] = temp;
        }
    }
    
    // 合并run
    void merge(int start, int mid, int end) {
        // 如果已经有序，直接返回
        if (arr[mid - 1] <= arr[mid]) {
            return;
        }
        
        // 使用临时数组复制数据
        for (int i = start; i <= end; i++) {
            tmp[i] = arr[i];
        }
        
        int i = start;     // 左半部分的指针
        int j = mid;       // 右半部分的指针
        int k = start;     // 写入原数组的位置
        
        // 标准归并过程
        while (i < mid && j <= end) {
            if (tmp[i] <= tmp[j]) {
                arr[k++] = tmp[i++];
            } else {
                arr[k++] = tmp[j++];
            }
        }
        
        // 复制剩余元素
        while (i < mid) {
            arr[k++] = tmp[i++];
        }
        // 右边部分的剩余元素已经在正确位置，不需要再复制
    }
    
    // 使用galloping模式的优化归并
    void mergeWithGalloping(int start, int mid, int end) {
        // 如果已经有序，直接返回
        if (arr[mid - 1] <= arr[mid]) {
            return;
        }
        
        // 使用临时数组复制数据
        for (int i = start; i <= end; i++) {
            tmp[i] = arr[i];
        }
        
        int i = start;     // 左半部分的指针
        int j = mid;       // 右半部分的指针
        int k = start;     // 写入原数组的位置
        
        int leftRunCount = 0;  // 连续从左侧归并的计数
        int rightRunCount = 0; // 连续从右侧归并的计数
        
        // 标准归并过程，但添加了galloping模式切换
        while (i < mid && j <= end) {
            if (tmp[i] <= tmp[j]) {
                arr[k++] = tmp[i++];
                leftRunCount++;
                rightRunCount = 0;
                
                // 检查是否应进入galloping模式
                if (leftRunCount >= MIN_GALLOP) {
                    // 使用二分查找在右侧数组中找到第一个大于tmp[i]的位置
                    while (i < mid && tmp[i] <= tmp[j]) {
                        arr[k++] = tmp[i++];
                    }
                    leftRunCount = 0;
                }
            } else {
                arr[k++] = tmp[j++];
                rightRunCount++;
                leftRunCount = 0;
                
                // 检查是否应进入galloping模式
                if (rightRunCount >= MIN_GALLOP) {
                    // 使用二分查找在左侧数组中找到第一个大于tmp[j]的位置
                    while (j <= end && tmp[i] > tmp[j]) {
                        arr[k++] = tmp[j++];
                    }
                    rightRunCount = 0;
                }
            }
        }
        
        // 复制剩余元素
        while (i < mid) {
            arr[k++] = tmp[i++];
        }
        // 右边部分的剩余元素已经在正确位置，不需要再复制
    }
    
    // 寻找自然有序的run，如果递减则进行反转
    int countRunAndMakeAscending(int start, int n) {
        if (start >= n - 1) {
            return 1;
        }
        
        int runLength = 2;
        
        // 检查序列是递增还是递减
        if (arr[start + 1] < arr[start]) {
            // 递减序列
            for (int i = start + 2; i < n; i++) {
                if (arr[i] >= arr[i - 1]) {
                    break;
                }
                runLength++;
            }
            
            // 反转序列
            std::reverse(arr.begin() + start, arr.begin() + start + runLength);
        } else {
            // 递增序列
            for (int i = start + 2; i < n; i++) {
                if (arr[i] < arr[i - 1]) {
                    break;
                }
                runLength++;
            }
        }
        
        return runLength;
    }
    
public:
    // 构造函数
    TimSort(std::vector&lt;int&gt;& array) : arr(array), tmp(array.size()) {
        minRun = computeMinRun(array.size());
    }
    
    // 执行Tim排序
    void sort() {
        const int n = arr.size();
        if (n < 2) {
            return;  // 数组长度小于2，已经有序
        }
        
        // 用于存储run的起始位置和长度
        std::vector&lt;std::pair&lt;int, int&gt;&gt; runs;
        
        // 处理整个数组
        int start = 0;
        while (start < n) {
            // 寻找自然run
            int runLen = countRunAndMakeAscending(start, n);
            
            // 如果run长度小于minRun，使用插入排序扩展它
            if (runLen < minRun) {
                int force = std::min(n - start, minRun);
                binaryInsertionSort(start, start + force - 1);
                runLen = force;
            }
            
            // 将run加入栈中
            runs.push_back(std::make_pair(start, runLen));
            start += runLen;
            
            // 合并规则：保持X > Y + Z，Y > Z
            while (runs.size() >= 3) {
                auto X = runs[runs.size() - 3];
                auto Y = runs[runs.size() - 2];
                auto Z = runs[runs.size() - 1];
                
                if (X.second <= Y.second + Z.second && Y.second <= Z.second) {
                    // 违反合并规则，需要合并
                    if (X.second < Z.second) {
                        // 合并X和Y
                        mergeWithGalloping(X.first, X.first + X.second, Y.first + Y.second - 1);
                        runs[runs.size() - 3].second += Y.second;
                        runs.erase(runs.end() - 2);
                    } else {
                        // 合并Y和Z
                        mergeWithGalloping(Y.first, Z.first, Z.first + Z.second - 1);
                        runs[runs.size() - 2].second += Z.second;
                        runs.pop_back();
                    }
                } else {
                    break;
                }
            }
            
            // 处理只有两个run的情况
            while (runs.size() >= 2) {
                auto Y = runs[runs.size() - 2];
                auto Z = runs[runs.size() - 1];
                
                if (Y.second <= Z.second) {
                    mergeWithGalloping(Y.first, Z.first, Z.first + Z.second - 1);
                    runs[runs.size() - 2].second += Z.second;
                    runs.pop_back();
                } else {
                    break;
                }
            }
        }
        
        // 最终合并所有剩余的runs
        while (runs.size() > 1) {
            auto Y = runs[runs.size() - 2];
            auto Z = runs[runs.size() - 1];
            
            mergeWithGalloping(Y.first, Z.first, Z.first + Z.second - 1);
            runs[runs.size() - 2].second += Z.second;
            runs.pop_back();
        }
    }
};

// 对外提供的排序接口
void timSort(std::vector&lt;int&gt;& arr) {
    if (arr.size() <= 1) {
        return;
    }
    
    TimSort sorter(arr);
    sorter.sort();
}

// 测试代码
int main() {
    std::vector&lt;int&gt; arr = {5, 21, 7, 23, 19, 60, 18, 42, 44, 2, 10, 67, 4, 1, 8, 9, 3};
    
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    timSort(arr);
    
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}</code></pre>
                    </div>
                    
                    <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r mt-6">
                        <div class="flex items-start">
                            <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-3"></i>
                            <div>
                                <h3 class="font-semibold text-gray-800">代码实现说明</h3>
                                <p class="text-gray-700">
                                    上面的实现包含了Tim排序的核心组件，但为了简洁略去了一些优化。完整的Tim排序实现通常还包括：<br>
                                    - 更复杂的galloping模式实现，带有自适应切换<br>
                                    - 更多的边界条件处理<br>
                                    - 针对临时数组的内存优化<br>
                                    - 专门处理重复元素的策略<br>
                                    - 针对不同数据类型和比较器的模板实现
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <p class="text-gray-700 mt-6">Tim排序的主要组件解释：</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
                        <div class="bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
                            <h3 class="font-semibold text-gray-800 mb-2">1. MinRun计算</h3>
                            <p class="text-gray-700">
                                计算最小run长度的函数确保归并树是平衡的，通常取值在16到32之间。算法通过位操作计算最接近n/2^k的2的幂，其中k使得n/2^k落在[16,32)区间。
                            </p>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
                            <h3 class="font-semibold text-gray-800 mb-2">2. 二分插入排序</h3>
                            <p class="text-gray-700">
                                对于小数组或run的扩展，Tim排序使用二分插入排序。它使用二分查找快速找到插入位置，比标准插入排序更高效。
                            </p>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
                            <h3 class="font-semibold text-gray-800 mb-2">3. 自然Run识别</h3>
                            <p class="text-gray-700">
                                countRunAndMakeAscending函数识别自然有序的片段，并将递减序列反转为递增序列。这是利用数据自然顺序性的关键步骤。
                            </p>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
                            <h3 class="font-semibold text-gray-800 mb-2">4. Galloping归并</h3>
                            <p class="text-gray-700">
                                当连续多次从同一子数组选择元素时，切换到galloping模式，使用二分查找加速归并过程，对于结构化数据尤其有效。
                            </p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 算法分析 -->
            <section class="section bg-white rounded-xl p-8 shadow-md">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <i class="fas fa-chart-line text-primary mr-3"></i>时间复杂度分析
                </h2>
                <div class="space-y-4">
                    <p class="text-gray-700">Tim排序是一种混合排序算法，其性能取决于输入数据的特征。以下是其复杂度分析：</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <h3 class="font-semibold text-gray-800 mb-2">时间复杂度</h3>
                            <div class="space-y-2">
                                <p><span class="font-mono font-medium">最坏情况</span>：O(n log n)</p>
                                <p><span class="font-mono font-medium">最好情况</span>：O(n)</p>
                                <p><span class="font-mono font-medium">平均情况</span>：O(n log n)</p>
                            </div>
                            <div class="mt-3 text-sm text-gray-600">
                                <p>Tim排序的时间复杂度分析：</p>
                                <ul class="list-disc list-inside mt-1">
                                    <li>寻找和扩展runs: O(n)</li>
                                    <li>归并runs: O(n log n) 在最坏情况下</li>
                                    <li>对于已经排序的数据: O(n)</li>
                                    <li>对于部分有序数据: 介于O(n)和O(n log n)之间</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <h3 class="font-semibold text-gray-800 mb-2">空间复杂度</h3>
                            <p class="font-mono font-medium">O(n)</p>
                            <div class="mt-3 text-sm text-gray-600">
                                <p>Tim排序需要额外的空间来存储：</p>
                                <ul class="list-disc list-inside mt-1">
                                    <li>临时数组用于归并: O(n)</li>
                                    <li>runs栈: O(log n) - 通常可以忽略不计</li>
                                </ul>
                                <p class="mt-2">实际实现中会尽量优化空间使用，如尝试重用临时空间和部分原地归并。</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <h3 class="font-semibold text-gray-800 mb-2">自适应性</h3>
                            <p class="text-gray-700">Tim排序的一个主要优势是它的自适应性：</p>
                            <ul class="list-disc list-inside mt-2 text-gray-700">
                                <li>对于随机数据：表现为O(n log n)</li>
                                <li>对于近乎有序的数据：接近O(n)</li>
                                <li>对于有许多相等元素的数据：表现优异</li>
                                <li>对于大规模数据中的小型重复模式：高效处理</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <h3 class="font-semibold text-gray-800 mb-2">稳定性</h3>
                            <p class="text-gray-700">Tim排序是<span class="text-green-600 font-medium">稳定</span>的排序算法，相同的元素在排序后保持其原始顺序。</p>
                            <p class="text-gray-700 mt-2">稳定性对于多级排序（先按一个关键字排序，然后按另一个关键字排序）非常重要，也使得它适用于处理复杂数据类型和对象排序。</p>
                        </div>
                    </div>
                    
                    <div class="bg-blue-50 p-4 rounded-lg mt-6">
                        <h3 class="font-semibold text-blue-800 mb-2">与其他排序算法的比较</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white">
                                <thead>
                                    <tr class="bg-blue-100">
                                        <th class="py-2 px-3 text-left">算法</th>
                                        <th class="py-2 px-3 text-left">最坏情况</th>
                                        <th class="py-2 px-3 text-left">最好情况</th>
                                        <th class="py-2 px-3 text-left">平均情况</th>
                                        <th class="py-2 px-3 text-left">空间复杂度</th>
                                        <th class="py-2 px-3 text-left">稳定性</th>
                                    </tr>
                                </thead>
                                <tbody class="divide-y divide-gray-200">
                                    <tr>
                                        <td class="py-2 px-3 font-medium">Tim排序</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(n)</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(n)</td>
                                        <td class="py-2 px-3 text-green-600">稳定</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-3 font-medium">快速排序</td>
                                        <td class="py-2 px-3">O(n²)</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(log n)</td>
                                        <td class="py-2 px-3 text-red-600">不稳定</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-3 font-medium">归并排序</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(n)</td>
                                        <td class="py-2 px-3 text-green-600">稳定</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-3 font-medium">堆排序</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(n log n)</td>
                                        <td class="py-2 px-3">O(1)</td>
                                        <td class="py-2 px-3 text-red-600">不稳定</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-3 font-medium">插入排序</td>
                                        <td class="py-2 px-3">O(n²)</td>
                                        <td class="py-2 px-3">O(n)</td>
                                        <td class="py-2 px-3">O(n²)</td>
                                        <td class="py-2 px-3">O(1)</td>
                                        <td class="py-2 px-3 text-green-600">稳定</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm">
                            <div>
                                <p class="font-semibold">Tim排序对比快速排序的优势：</p>
                                <ul class="list-disc list-inside text-gray-700">
                                    <li>稳定排序</li>
                                    <li>保证O(n log n)的最坏情况</li>
                                    <li>更好地处理部分有序数据</li>
                                </ul>
                            </div>
                            <div>
                                <p class="font-semibold">Tim排序对比归并排序的优势：</p>
                                <ul class="list-disc list-inside text-gray-700">
                                    <li>利用数据的自然顺序性</li>
                                    <li>对小数组使用插入排序</li>
                                    <li>有更多的优化技术如galloping模式</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 交互式可视化 -->
            <section class="section bg-white rounded-xl p-8 shadow-md">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <i class="fas fa-chart-bar text-primary mr-3"></i>交互式可视化
                </h2>
                
                <div class="space-y-6">
                    <p class="text-gray-700">通过下面的交互式可视化，您可以观察Tim排序的运行过程，了解算法如何识别和处理runs，并逐步将它们合并成完全排序的数组。</p>
                    
                    <!-- 控制面板 -->
                    <div class="flex flex-wrap gap-4 mb-6 bg-gray-100 p-4 rounded-lg shadow-inner">
                        <button id="newArrayBtn" class="px-4 py-2 bg-primary hover:bg-primary-dark text-white rounded-lg transition-all duration-200 flex items-center shadow-md focus:outline-none focus:ring-2 focus:ring-primary-light">
                            <i class="fas fa-random mr-2"></i>新数组
                        </button>
                        <button id="startBtn" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-all duration-200 flex items-center shadow-md focus:outline-none focus:ring-2 focus:ring-green-300">
                            <i class="fas fa-play mr-2"></i>开始排序
                        </button>
                        <button id="stepBtn" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-all duration-200 flex items-center shadow-md focus:outline-none focus:ring-2 focus:ring-blue-300">
                            <i class="fas fa-step-forward mr-2"></i>单步执行
                        </button>
                        <button id="resetBtn" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg transition-all duration-200 flex items-center shadow-md focus:outline-none focus:ring-2 focus:ring-red-300" disabled>
                            <i class="fas fa-undo-alt mr-2"></i>重置
                        </button>
                        
                        <div class="flex items-center ml-auto">
                            <label for="speed" class="text-sm text-gray-700 mr-2">速度:</label>
                            <input id="speed" type="range" min="1" max="5" value="3" class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                            <span id="speedValue" class="ml-2 text-sm text-gray-700">中等</span>
                        </div>
                        
                        <div class="flex items-center">
                            <label for="arraySize" class="text-sm text-gray-700 mr-2">数组大小:</label>
                            <select id="arraySize" class="bg-white border border-gray-300 rounded px-2 py-1 text-sm">
                                <option value="16">16</option>
                                <option value="32" selected>32</option>
                                <option value="64">64</option>
                            </select>
                        </div>
                        
                        <div class="flex items-center">
                            <label for="arrayType" class="text-sm text-gray-700 mr-2">数组类型:</label>
                            <select id="arrayType" class="bg-white border border-gray-300 rounded px-2 py-1 text-sm">
                                <option value="random" selected>随机</option>
                                <option value="nearlySorted">近乎有序</option>
                                <option value="reversed">倒序</option>
                                <option value="few">少量不同值</option>
                            </select>
                        </div>
                    </div>

                    <!-- 可视化区域 - 重新排列为上下结构 -->
                    <div class="flex flex-col space-y-6">
                        <!-- 当前阶段和统计信息 - 移到上方 -->
                        <div class="bg-gray-100 rounded-lg p-4 shadow-inner">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <!-- 当前阶段信息 -->
                                <div>
                                    <h3 class="text-lg font-semibold text-gray-800 mb-3 flex items-center">
                                        <i class="fas fa-tasks mr-2 text-primary"></i>当前阶段
                                    </h3>
                                    <div class="bg-white rounded-lg p-3 shadow-sm">
                                        <div class="flex justify-between items-center mb-1">
                                            <span class="text-sm font-medium text-gray-700">阶段:</span>
                                            <span id="current-phase" class="text-sm font-bold text-primary">等待开始</span>
                                        </div>
                                        <div class="flex justify-between items-center mb-1">
                                            <span class="text-sm font-medium text-gray-700">当前步骤:</span>
                                            <span id="current-step" class="text-sm font-bold text-primary">-</span>
                                        </div>
                                        <div class="flex justify-between items-center mb-1">
                                            <span class="text-sm font-medium text-gray-700">MinRun长度:</span>
                                            <span id="minrun" class="text-sm font-bold text-primary">-</span>
                                        </div>
                                        <div class="flex justify-between items-start mt-2">
                                            <span class="text-sm font-medium text-gray-700">步骤说明:</span>
                                            <span id="step-info" class="text-sm text-gray-700 flex-1 text-right">准备开始Tim排序。点击"开始排序"按钮开始，或使用"单步执行"按钮逐步观察排序过程。</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- 统计信息 -->
                                <div>
                                    <h3 class="text-lg font-semibold text-gray-800 mb-3 flex items-center">
                                        <i class="fas fa-chart-pie mr-2 text-primary"></i>统计信息
                                    </h3>
                                    <div class="bg-white rounded-lg p-3 shadow-sm">
                                        <div class="grid grid-cols-3 gap-3">
                                            <div class="p-2 bg-blue-50 rounded-lg">
                                                <div class="text-xs text-gray-500">比较次数</div>
                                                <div id="compare-count" class="text-xl font-bold text-primary">0</div>
                                            </div>
                                            <div class="p-2 bg-green-50 rounded-lg">
                                                <div class="text-xs text-gray-500">交换次数</div>
                                                <div id="swap-count" class="text-xl font-bold text-green-500">0</div>
                                            </div>
                                            <div class="p-2 bg-purple-50 rounded-lg">
                                                <div class="text-xs text-gray-500">合并次数</div>
                                                <div id="merge-count" class="text-xl font-bold text-purple-500">0</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 数组可视化 - 独立区域 -->
                        <div class="bg-gray-100 rounded-lg p-4 shadow-inner">
                            <h3 class="text-lg font-semibold text-gray-800 mb-3 flex items-center">
                                <i class="fas fa-list-ol mr-2 text-primary"></i>数组可视化
                            </h3>
                            <div id="array-container" class="bg-white rounded-lg p-4 shadow-sm min-h-[360px] flex flex-col">
                                <div id="array-bars" class="flex justify-center items-end h-60 mb-8 overflow-x-auto"></div>
                                <div id="array-runs" class="flex flex-col gap-4 w-full max-h-[300px] overflow-y-auto p-2"></div>
                                
                                <!-- 图例说明 - 移到数组可视化区域内 -->
                                <div class="mt-4 p-3 bg-gray-50 rounded-lg shadow-sm">
                                    <h3 class="text-sm font-semibold text-gray-700 mb-2">图例说明</h3>
                                    <div class="flex flex-wrap gap-x-6 gap-y-2 justify-center">
                                        <div class="flex items-center">
                                            <div class="w-4 h-4 bg-gray-300 rounded mr-2"></div>
                                            <span class="text-xs text-gray-700">未排序元素</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-4 h-4 bg-blue-500 rounded mr-2"></div>
                                            <span class="text-xs text-gray-700">Run 1</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-4 h-4 bg-green-500 rounded mr-2"></div>
                                            <span class="text-xs text-gray-700">Run 2</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-4 h-4 bg-purple-500 rounded mr-2"></div>
                                            <span class="text-xs text-gray-700">Run 3</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-4 h-4 bg-yellow-500 rounded mr-2"></div>
                                            <span class="text-xs text-gray-700">当前比较元素</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-4 h-4 bg-pink-500 rounded mr-2"></div>
                                            <span class="text-xs text-gray-700">插入位置</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-4 h-4 bg-green-500 rounded mr-2"></div>
                                            <span class="text-xs text-gray-700">已排序元素</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 排序过程说明 -->
                    <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r shadow-sm">
                        <h3 class="font-semibold text-gray-800 mb-2">Tim排序过程简述</h3>
                        <ol class="list-decimal list-inside space-y-1 text-sm text-gray-700">
                            <li>扫描数组，识别已排序的<b>runs</b>（递增或严格递减的子序列，递减会被反转）</li>
                            <li>使用<b>插入排序</b>将小于minRun长度的runs扩展到适当大小</li>
                            <li>将标识出的runs压入<b>栈</b>中</li>
                            <li>根据特定规则<b>合并</b>栈中的相邻runs</li>
                            <li>最终合并所有runs，得到完全排序的数组</li>
                        </ol>
                    </div>
                </div>
            </section>

            <!-- 应用场景 -->
            <section class="section bg-white rounded-xl p-8 shadow-md">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <i class="fas fa-tasks text-primary mr-3"></i>应用场景
                </h2>
                
                <div class="space-y-4">
                    <p class="text-gray-700">由于其稳定性、高效性和对各种数据分布的良好适应性，Tim排序在许多关键领域得到了广泛应用：</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                        <div class="card-hover bg-white p-5 rounded-lg border border-gray-200 shadow-sm">
                            <div class="flex items-center mb-3">
                                <i class="fas fa-code text-primary mr-3 text-xl"></i>
                                <h3 class="font-semibold text-gray-800">编程语言标准库</h3>
                            </div>
                            <p class="text-gray-600">Tim排序被多种主流编程语言采用为其标准库中的默认排序算法，包括Python、Java、Android Java、Swift和OpenJDK等。</p>
                        </div>
                        
                        <div class="card-hover bg-white p-5 rounded-lg border border-gray-200 shadow-sm">
                            <div class="flex items-center mb-3">
                                <i class="fas fa-database text-primary mr-3 text-xl"></i>
                                <h3 class="font-semibold text-gray-800">数据库系统</h3>
                            </div>
                            <p class="text-gray-600">许多数据库系统使用Tim排序来处理查询结果排序，尤其是当数据可能部分有序时（如时间序列数据或索引范围查询）。</p>
                        </div>
                        
                        <div class="card-hover bg-white p-5 rounded-lg border border-gray-200 shadow-sm">
                            <div class="flex items-center mb-3">
                                <i class="fas fa-table text-primary mr-3 text-xl"></i>
                                <h3 class="font-semibold text-gray-800">电子表格应用</h3>
                            </div>
                            <p class="text-gray-600">电子表格应用如Microsoft Excel等在对大型表格进行多级排序时使用类似Tim排序的算法，因为需要维持相同值记录的原始顺序。</p>
                        </div>
                        
                        <div class="card-hover bg-white p-5 rounded-lg border border-gray-200 shadow-sm">
                            <div class="flex items-center mb-3">
                                <i class="fas fa-server text-primary mr-3 text-xl"></i>
                                <h3 class="font-semibold text-gray-800">大数据处理</h3>
                            </div>
                            <p class="text-gray-600">在大数据处理框架中，如Apache Spark等，Tim排序被用于处理大规模数据集的排序任务，尤其是在外部归并阶段。</p>
                        </div>
                        
                        <div class="card-hover bg-white p-5 rounded-lg border border-gray-200 shadow-sm">
                            <div class="flex items-center mb-3">
                                <i class="fas fa-chart-line text-primary mr-3 text-xl"></i>
                                <h3 class="font-semibold text-gray-800">分析系统</h3>
                            </div>
                            <p class="text-gray-600">数据分析和商业智能系统在处理大量时间序列数据或已部分排序的数据集时，依赖Tim排序的高效性。</p>
                        </div>
                        
                        <div class="card-hover bg-white p-5 rounded-lg border border-gray-200 shadow-sm">
                            <div class="flex items-center mb-3">
                                <i class="fas fa-sort-alpha-down text-primary mr-3 text-xl"></i>
                                <h3 class="font-semibold text-gray-800">文本处理</h3>
                            </div>
                            <p class="text-gray-600">文本处理工具在对大型文本语料库进行排序或在搜索引擎索引构建过程中，利用Tim排序的稳定性和效率。</p>
                        </div>
                    </div>
                    
                    <div class="bg-blue-50 p-6 rounded-lg mt-6">
                        <h3 class="text-xl text-blue-700 font-semibold mb-3">真实世界中的应用举例</h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-700">
                            <li>Python从2.3版本开始使用Tim排序作为其<code>list.sort()</code>和<code>sorted()</code>函数的实现</li>
                            <li>Java从Java 7开始用Tim排序替代归并排序来实现<code>Arrays.sort()</code>和<code>Collections.sort()</code></li>
                            <li>Android SDK中的<code>Collections</code>类使用Tim排序</li>
                            <li>V8 JavaScript引擎在某些情况下使用Tim排序的变种</li>
                            <li>数据可视化库如D3.js和Matplotlib在处理数据时可能使用Tim排序</li>
                            <li>大型在线分析处理（OLAP）系统在处理数据立方体排序时使用Tim排序</li>
                        </ul>
                    </div>
                    
                    <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r mt-6">
                        <div class="flex items-start">
                            <i class="fas fa-lightbulb text-yellow-500 mt-1 mr-3"></i>
                            <div>
                                <h3 class="font-semibold text-gray-800">为什么选择Tim排序</h3>
                                <p class="text-gray-700">
                                    Tim排序在实际应用中优于其他排序算法的关键原因：
                                </p>
                                <ol class="list-decimal list-inside mt-2 text-gray-700">
                                    <li>对真实世界数据的优化 — 大多数实际数据集都不是完全随机的，而是含有部分有序结构</li>
                                    <li>稳定性 — 在处理复杂对象排序时保持相等元素的原始顺序</li>
                                    <li>可预测的性能 — 无论输入数据如何，都能保证O(n log n)的最坏情况时间复杂度</li>
                                    <li>高效处理已部分排序或包含重复元素的数据集</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
        
        <!-- 页脚 -->
        <footer class="mt-10 p-6 bg-gray-800 text-white flex flex-col md:flex-row justify-between items-center">
            <div class="mb-4 md:mb-0">
                <p class="text-sm"> </p>
            </div>
            <div class="flex space-x-4">
                <a href="index.html" class="text-gray-300 hover:text-white transition-colors">首页</a>
                <a href="桶排序.html" class="text-gray-300 hover:text-white transition-colors">桶排序</a>
                <a href="希尔排序.html" class="text-gray-300 hover:text-white transition-colors">希尔排序</a>
                <a href="锦标赛排序.html" class="text-gray-300 hover:text-white transition-colors">锦标赛排序</a>
            </div>
            <button id="back-to-top" class="fixed right-6 bottom-6 p-3 bg-primary rounded-full shadow-lg text-white hidden">
                <i class="fas fa-arrow-up"></i>
            </button>
        </footer>
        
        <!-- ScrollReveal -->
        <script src="https://unpkg.com/scrollreveal"></script>
        
        <!-- Highlight.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
        
        <script>
            // ScrollReveal 初始化
            ScrollReveal().reveal('.section, h2, .bg-white', {
                distance: '50px',
                duration: 1000,
                delay: 200,
                easing: 'cubic-bezier(0.5, 0, 0, 1)'
            });
            
            // 回到顶部按钮
            const backToTopButton = document.getElementById('back-to-top');
            
            window.addEventListener('scroll', () => {
                if (window.pageYOffset > 300) {
                    backToTopButton.classList.remove('hidden');
                } else {
                    backToTopButton.classList.add('hidden');
                }
            });
            
            backToTopButton.addEventListener('click', () => {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });

            // Tim排序可视化实现
            document.addEventListener('DOMContentLoaded', function() {
                // 获取DOM元素
                const arrayBars = document.getElementById('array-bars');
                const arrayRuns = document.getElementById('array-runs');
                const newArrayBtn = document.getElementById('newArrayBtn');
                const startBtn = document.getElementById('startBtn');
                const stepBtn = document.getElementById('stepBtn');
                const resetBtn = document.getElementById('resetBtn');
                const speedSlider = document.getElementById('speed');
                const speedValue = document.getElementById('speedValue');
                const arraySizeSelect = document.getElementById('arraySize');
                const arrayTypeSelect = document.getElementById('arrayType');
                const stepInfo = document.getElementById('step-info');
                const currentPhase = document.getElementById('current-phase');
                const currentStep = document.getElementById('current-step');
                const minrunDisplay = document.getElementById('minrun');
                const compareCount = document.getElementById('compare-count');
                const swapCount = document.getElementById('swap-count');
                const mergeCount = document.getElementById('merge-count');
                
                // 常量定义
                const ARRAY_COLOR = 'bg-gray-300';
                const COMPARED_COLOR = 'bg-yellow-500';
                const SORTED_COLOR = 'bg-green-500';
                const SELECTED_COLOR = 'bg-red-500';
                const INSERT_COLOR = 'bg-pink-500';
                const RUN_COLORS = ['bg-blue-500', 'bg-green-500', 'bg-purple-500', 'bg-red-500', 'bg-orange-500', 'bg-indigo-500'];
                
                // 变量定义
                let array = [];
                let originalArray = [];
                let barElements = [];
                let runMarkers = [];
                let runs = [];
                let minRun = 0;
                let comparisons = 0;
                let swaps = 0;
                let merges = 0;
                let sortingAnimations = [];
                let animationIndex = 0;
                let sortingTimeout;
                let isSorting = false;
                let isStepMode = false;
                
                // 速度映射
                const speedMap = {
                    1: { label: '非常慢', value: 1000 },
                    2: { label: '慢', value: 500 },
                    3: { label: '中等', value: 250 },
                    4: { label: '快', value: 100 },
                    5: { label: '非常快', value: 20 }
                };
                
                // 生成新数组
                function generateArray() {
                    // 显示生成中的视觉反馈
                    stepInfo.textContent = '正在生成新数组...';
                    
                    // 重置排序状态
                    if (isSorting) {
                        resetSorting();
                    }
                    
                    const size = parseInt(arraySizeSelect.value);
                    const type = arrayTypeSelect.value;
                    
                    array = [];
                    
                    switch(type) {
                        case 'random':
                            for (let i = 0; i < size; i++) {
                                array.push(Math.floor(Math.random() * 100) + 1);
                            }
                            stepInfo.textContent = '已生成随机数组。';
                            break;
                        case 'nearlySorted':
                            for (let i = 0; i < size; i++) {
                                array.push(i + 1);
                            }
                            // 交换几个元素
                            for (let i = 0; i < size * 0.1; i++) {
                                const idx1 = Math.floor(Math.random() * size);
                                const idx2 = Math.floor(Math.random() * size);
                                [array[idx1], array[idx2]] = [array[idx2], array[idx1]];
                            }
                            stepInfo.textContent = '已生成近乎有序的数组。';
                            break;
                        case 'reversed':
                            for (let i = 0; i < size; i++) {
                                array.push(size - i);
                            }
                            stepInfo.textContent = '已生成倒序数组。';
                            break;
                        case 'few':
                            const distinct = Math.min(5, Math.ceil(size * 0.2));
                            for (let i = 0; i < size; i++) {
                                array.push(Math.floor(Math.random() * distinct) + 1);
                            }
                            stepInfo.textContent = '已生成具有少量不同值的数组。';
                            break;
                    }
                    
                    originalArray = [...array];
                    runs = [];
                    
                    // 动画显示新数组
                    animateNewArray();
                    
                    // 更新最小Run长度显示
                    minRun = computeMinRun(array.length);
                    minrunDisplay.textContent = minRun;
                    
                    currentPhase.textContent = '等待开始';
                    currentStep.textContent = '-';
                    
                    // 重置统计数据
                    resetStats();
                }
                
                // 新数组生成动画
                async function animateNewArray() {
                    // 先渲染空数组
                    arrayBars.innerHTML = '';
                    barElements = [];
                    arrayRuns.innerHTML = '';
                    
                    renderArray();
                    
                    // 添加淡入效果
                    for (let i = 0; i < barElements.length; i++) {
                        barElements[i].classList.add('opacity-0');
                        setTimeout(() => {
                            barElements[i].classList.replace('opacity-0', 'opacity-100');
                        }, i * 20);
                    }
                }
                
                // 错误处理
                function handleError(error, message) {
                    console.error(error);
                    stepInfo.textContent = message || '发生错误，请重试。';
                    resetSorting();
                }
                
                // 渲染数组
                function renderArray(runHighlight = null, compareElements = [], insertPos = -1) {
                    arrayBars.innerHTML = '';
                    barElements = [];
                    
                    const maxValue = Math.max(...array);
                    const containerWidth = arrayBars.clientWidth;
                    
                    // 根据数组大小调整条形宽度
                    const numElements = array.length;
                    let barWidth;
                    
                    // 动态调整宽度以适应容器
                    if (numElements <= 16) {
                        barWidth = Math.floor((containerWidth - (numElements * 8)) / numElements);
                        barWidth = Math.max(16, Math.min(barWidth, 32)); // 16-32px
                    } else if (numElements <= 32) {
                        barWidth = Math.floor((containerWidth - (numElements * 6)) / numElements);
                        barWidth = Math.max(10, Math.min(barWidth, 20)); // 10-20px
                    } else {
                        barWidth = Math.floor((containerWidth - (numElements * 4)) / numElements);
                        barWidth = Math.max(6, Math.min(barWidth, 14)); // 6-14px
                    }
                    
                    // 确定是否需要显示run分隔线
                    const showRunDividers = runs.length > 0;
                    
                    // 创建容器
                    const arrayContainer = document.createElement('div');
                    arrayContainer.className = 'relative w-full flex justify-center items-end flex-wrap';
                    arrayBars.appendChild(arrayContainer);
                    
                    for (let i = 0; i < array.length; i++) {
                        const height = (array[i] / maxValue) * 100;
                        
                        // 创建bar容器
                        const barContainer = document.createElement('div');
                        barContainer.className = 'flex flex-col items-center relative mx-1 mb-6';
                        
                        // 创建bar
                        const bar = document.createElement('div');
                        bar.className = `rounded-t transition-all duration-200 ${ARRAY_COLOR}`;
                        bar.style.width = `${barWidth}px`;
                        bar.style.height = `${Math.max(10, height)}%`;
                        
                        // 设置标签 - 使用定位避免空间问题
                        const label = document.createElement('div');
                        label.className = 'absolute bottom-[-20px] text-xs text-center font-medium';
                        label.style.width = `${barWidth * 1.2}px`;
                        
                        // 对较长数字进行截断处理，显示"..."
                        const valueText = array[i].toString();
                        label.textContent = valueText.length > 4 ? valueText.slice(0, 3) + '…' : valueText;
                        
                        // 添加工具提示显示完整值
                        if (valueText.length > 4) {
                            label.title = valueText;
                            label.className += ' cursor-help';
                        }
                        
                        // 设置颜色 - 优先显示Run的颜色
                        const runIndex = findRunIndex(i);
                        if (runIndex !== -1) {
                            bar.classList.remove(ARRAY_COLOR);
                            bar.classList.add(RUN_COLORS[runIndex % RUN_COLORS.length]);
                            
                            // 添加Run标记 - 在每个Run的第一个元素上
                            if (i === runs[runIndex].start) {
                                const runLabel = document.createElement('div');
                                runLabel.className = 'absolute -top-7 text-xs font-semibold rounded px-2 py-1 text-white';
                                runLabel.textContent = `Run ${runIndex + 1}`;
                                runLabel.style.backgroundColor = getComputedStyle(document.documentElement)
                                    .getPropertyValue(`--${RUN_COLORS[runIndex % RUN_COLORS.length].replace('bg-', '')}`);
                                barContainer.appendChild(runLabel);
                                
                                // 显示分隔线
                                if (i > 0 && showRunDividers) {
                                    const divider = document.createElement('div');
                                    divider.className = 'absolute h-full w-1 bg-gray-400 -left-2 rounded';
                                    barContainer.appendChild(divider);
                                }
                            }
                            
                            // 设置标签颜色以匹配run
                            label.style.color = getComputedStyle(document.documentElement)
                                .getPropertyValue(`--${RUN_COLORS[runIndex % RUN_COLORS.length].replace('bg-', '')}`);
                            label.classList.add('font-bold');
                        }
                        
                        // 临时高亮特定run进行演示
                        else if (runHighlight && runHighlight.includes(i)) {
                            bar.classList.remove(ARRAY_COLOR);
                            // 使用不同的颜色表示临时识别的run
                            bar.classList.add('bg-purple-400');
                            label.style.color = getComputedStyle(document.documentElement)
                                .getPropertyValue('--purple-400');
                        }
                        
                        // 比较元素高亮
                        if (compareElements.includes(i)) {
                            bar.classList.remove(ARRAY_COLOR);
                            bar.classList.add(COMPARED_COLOR);
                            // 高亮比较元素的标签
                            label.style.color = getComputedStyle(document.documentElement)
                                .getPropertyValue('--yellow-500');
                            label.classList.add('font-bold');
                        }
                        
                        // 插入位置高亮
                        if (i === insertPos) {
                            bar.classList.remove(ARRAY_COLOR);
                            bar.classList.add(INSERT_COLOR);
                            // 高亮插入位置的标签
                            label.style.color = getComputedStyle(document.documentElement)
                                .getPropertyValue('--pink-500');
                            label.classList.add('font-bold');
                        }
                        
                        // 添加阴影效果和边框
                        bar.classList.add('shadow-sm', 'border', 'border-gray-200');
                        
                        barContainer.appendChild(bar);
                        barContainer.appendChild(label);
                        
                        arrayContainer.appendChild(barContainer);
                        barElements.push(bar);
                    }
                    
                    // 更新Runs显示
                    updateRunsDisplay();
                }
                
                // 查找元素所在的Run
                function findRunIndex(elementIndex) {
                    for (let i = 0; i < runs.length; i++) {
                        if (elementIndex >= runs[i].start && elementIndex < runs[i].start + runs[i].length) {
                            return i;
                        }
                    }
                    return -1;
                }
                
                // 更新Runs显示
                function updateRunsDisplay() {
                    arrayRuns.innerHTML = '';
                    
                    if (runs.length === 0) {
                        // 显示空状态提示
                        const emptyState = document.createElement('div');
                        emptyState.className = 'text-center text-gray-500 py-4 italic text-sm';
                        emptyState.textContent = '暂无已识别的Runs';
                        arrayRuns.appendChild(emptyState);
                        return;
                    }
                    
                    // 创建标题
                    const title = document.createElement('div');
                    title.className = 'text-sm font-semibold text-gray-700 mb-3 sticky top-0 bg-white p-2 border-b';
                    title.innerHTML = '<i class="fas fa-layer-group mr-1"></i> 已识别的Runs (' + runs.length + ')';
                    arrayRuns.appendChild(title);
                    
                    // 为每个run创建卡片
                    runs.forEach((run, i) => {
                        const runElement = document.createElement('div');
                        const bgColorClass = RUN_COLORS[i % RUN_COLORS.length];
                        const bgColorVar = `--${bgColorClass.replace('bg-', '')}`;
                        const bgColorValue = getComputedStyle(document.documentElement).getPropertyValue(bgColorVar);
                        
                        runElement.className = `p-3 rounded-lg shadow-sm hover:shadow-md transition-shadow border-l-4 mb-2`;
                        runElement.style.backgroundColor = `rgba(${hexToRgb(bgColorValue)}, 0.1)`;
                        runElement.style.borderLeftColor = bgColorValue;
                        
                        // 添加运行标题
                        const header = document.createElement('div');
                        header.className = 'flex items-center font-semibold mb-2 text-sm';
                        header.style.color = bgColorValue;
                        header.innerHTML = `<i class="fas fa-layer-group mr-2"></i> Run ${i+1}`;
                        runElement.appendChild(header);
                        
                        // 添加Run详情
                        const details = document.createElement('div');
                        details.className = 'space-y-1 text-xs';
                        
                        // 信息行 - 位置和长度
                        const infoRow = document.createElement('div');
                        infoRow.className = 'grid grid-cols-2 gap-2';
                        
                        // 位置信息
                        const position = document.createElement('div');
                        position.className = 'flex justify-between';
                        position.innerHTML = `<span class="font-medium text-gray-600">位置范围:</span> <span class="font-mono">[${run.start} → ${run.start + run.length - 1}]</span>`;
                        infoRow.appendChild(position);
                        
                        // 长度信息
                        const length = document.createElement('div');
                        length.className = 'flex justify-between';
                        length.innerHTML = `<span class="font-medium text-gray-600">长度:</span> <span class="font-mono">${run.length}</span>`;
                        infoRow.appendChild(length);
                        
                        details.appendChild(infoRow);
                        
                        // 值信息 - 显示所有值
                        const values = array.slice(run.start, run.start + run.length);
                        const valuesContainer = document.createElement('div');
                        valuesContainer.className = 'mt-2';
                        
                        const valuesLabel = document.createElement('div');
                        valuesLabel.className = 'font-medium text-gray-600 mb-1';
                        valuesLabel.textContent = '包含元素:';
                        valuesContainer.appendChild(valuesLabel);
                        
                        // 创建一个元素标签容器 - 使用flex-wrap确保多行显示
                        const valueChips = document.createElement('div');
                        valueChips.className = 'flex flex-wrap gap-1 w-full overflow-hidden';
                        
                        // 为每个值创建一个标签
                        values.forEach((value, idx) => {
                            const chip = document.createElement('div');
                            chip.className = 'px-1.5 py-0.5 mb-1 rounded text-white text-xs font-mono inline-block';
                            chip.style.backgroundColor = bgColorValue;
                            
                            // 对较长数字进行截断处理
                            const valueText = value.toString();
                            chip.textContent = valueText.length > 4 ? valueText.slice(0, 3) + '…' : valueText;
                            
                            // 添加工具提示显示完整值
                            if (valueText.length > 4) {
                                chip.title = valueText;
                                chip.className += ' cursor-help';
                            }
                            
                            // 添加点击行为 - 点击高亮对应的数组元素
                            chip.addEventListener('click', () => {
                                // 首先重置所有元素
                                barElements.forEach(el => el.classList.remove('animate-pulse'));
                                // 然后高亮当前元素
                                const elementIndex = run.start + idx;
                                if (barElements[elementIndex]) {
                                    barElements[elementIndex].classList.add('animate-pulse');
                                    // 3秒后取消高亮
                                    setTimeout(() => {
                                        barElements[elementIndex].classList.remove('animate-pulse');
                                    }, 3000);
                                }
                            });
                            
                            valueChips.appendChild(chip);
                        });
                        
                        valuesContainer.appendChild(valueChips);
                        details.appendChild(valuesContainer);
                        
                        runElement.appendChild(details);
                        
                        // 添加交互效果 - 鼠标悬停时高亮对应的数组元素
                        runElement.addEventListener('mouseenter', () => {
                            // 高亮这个run的所有元素
                            for (let j = run.start; j < run.start + run.length; j++) {
                                if (barElements[j]) {
                                    barElements[j].classList.add('animate-pulse');
                                }
                            }
                        });
                        
                        runElement.addEventListener('mouseleave', () => {
                            // 取消高亮
                            for (let j = run.start; j < run.start + run.length; j++) {
                                if (barElements[j]) {
                                    barElements[j].classList.remove('animate-pulse');
                                }
                            }
                        });
                        
                        arrayRuns.appendChild(runElement);
                    });
                }
                
                // 辅助函数：将十六进制颜色转换为RGB
                function hexToRgb(hex) {
                    // 移除#前缀（如果有）
                    hex = hex.replace(/^#/, '');
                    
                    // 如果是缩写形式，展开
                    if (hex.length === 3) {
                        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                    }
                    
                    // 解析为RGB
                    const r = parseInt(hex.substring(0, 2), 16);
                    const g = parseInt(hex.substring(2, 4), 16);
                    const b = parseInt(hex.substring(4, 6), 16);
                    
                    return `${r}, ${g}, ${b}`;
                }
                
                // 重置统计数据
                function resetStats() {
                    comparisons = 0;
                    swaps = 0;
                    merges = 0;
                    compareCount.textContent = '0';
                    swapCount.textContent = '0';
                    mergeCount.textContent = '0';
                }
                
                // 计算MinRun
                function computeMinRun(n) {
                    let r = 0;
                    while (n >= 32) {
                        r |= (n & 1);
                        n >>= 1;
                    }
                    return n + r;
                }
                
                // 暂停函数
                function sleep(ms) {
                    return new Promise(resolve => {
                        sortingTimeout = setTimeout(resolve, ms);
                    });
                }
                
                // 计算延迟时间
                function getDelay() {
                    return speedMap[speedSlider.value].value;
                }
                
                // Tim排序实现
                async function timSort() {
                    const n = array.length;
                    runs = [];
                    
                    // 计算minRun
                    const minRun = computeMinRun(n);
                    minrunDisplay.textContent = minRun;
                    
                    // 第一阶段：识别自然runs并扩展
                    currentPhase.textContent = '识别并扩展Runs';
                    stepInfo.textContent = `开始识别数组中的自然runs。最小run长度（minRun）为 ${minRun}。`;
                    renderArray();
                    await handleAnimation();
                    
                    let currentPosition = 0;
                    
                    while (currentPosition < n) {
                        // 识别下一个run
                        stepInfo.textContent = `从位置 ${currentPosition} 开始识别自然run...`;
                        currentStep.textContent = `识别Run: 位置 ${currentPosition}`;
                        
                        // 高亮当前位置
                        renderArray(null, [currentPosition]);
                        await handleAnimation();
                        
                        // 识别run的长度
                        let runLength = identifyRun(currentPosition);
                        
                        // 创建run范围数组并高亮显示
                        const identified = [...Array(runLength).keys()].map(i => i + currentPosition);
                        stepInfo.textContent = `在位置 ${currentPosition} 发现自然run，长度为 ${runLength}`;
                        renderArray(identified);
                        await handleAnimation();
                        
                        // 如果run太短，使用插入排序扩展它
                        if (runLength < minRun) {
                            const forcedLength = Math.min(n - currentPosition, minRun);
                            
                            if (runLength < forcedLength) {
                                stepInfo.textContent = `Run长度(${runLength}) < minRun(${minRun})，使用插入排序扩展到 ${forcedLength}`;
                                currentStep.textContent = `扩展Run: 位置 ${currentPosition}`;
                                
                                // 高亮需要扩展的部分
                                const extensionElements = [...Array(forcedLength - runLength).keys()].map(i => i + currentPosition + runLength);
                                renderArray(identified.concat(extensionElements));
                                await handleAnimation();
                                
                                // 使用插入排序扩展
                                await insertionSort(currentPosition, currentPosition + forcedLength - 1);
                                runLength = forcedLength;
                            }
                        }
                        
                        // 添加当前run
                        const newRun = { start: currentPosition, length: runLength };
                        runs.push(newRun);
                        
                        // 更新当前位置
                        currentPosition += runLength;
                        
                        // 显示已添加的run
                        stepInfo.textContent = `已添加Run ${runs.length}，范围 [${newRun.start}:${newRun.start + newRun.length - 1}]`;
                        renderArray();
                        await handleAnimation();
                        
                        // 如果已经创建了多个run，展示所有run
                        if (runs.length > 1) {
                            stepInfo.textContent = `已识别 ${runs.length} 个runs，每个run均已排序`;
                            renderArray();
                            await handleAnimation();
                        }
                    }
                    
                    // 第二阶段：合并runs
                    currentPhase.textContent = '合并Runs';
                    stepInfo.textContent = `识别阶段完成。共识别出 ${runs.length} 个runs，开始合并过程...`;
                    renderArray();
                    await handleAnimation();
                    
                    // 模拟Tim排序的合并规则
                    while (runs.length > 1) {
                        // 找到需要合并的runs
                        let i = findRunToMerge();
                        
                        if (i !== -1) {
                            let run1 = runs[i];
                            let run2 = runs[i + 1];
                            
                            // 高亮要合并的两个run
                            const run1Elements = [...Array(run1.length).keys()].map(j => j + run1.start);
                            const run2Elements = [...Array(run2.length).keys()].map(j => j + run2.start);
                            
                            stepInfo.textContent = `选择合并: Run ${i+1} (位置 ${run1.start}-${run1.start + run1.length - 1}) 和 Run ${i+2} (位置 ${run2.start}-${run2.start + run2.length - 1})`;
                            currentStep.textContent = `合并Runs: ${i+1} 和 ${i+2}`;
                            
                            // 突出显示要合并的runs
                            renderArray([...run1Elements, ...run2Elements]);
                            await handleAnimation();
                            
                            // 执行合并
                            await mergeRuns(run1.start, run1.start + run1.length - 1, run2.start + run2.length - 1);
                            
                            // 更新runs数组
                            runs[i].length += runs[i + 1].length;
                            runs.splice(i + 1, 1);
                            
                            merges++;
                            mergeCount.textContent = merges;
                            
                            stepInfo.textContent = `合并完成，现在有 ${runs.length} 个runs`;
                            renderArray();
                            await handleAnimation();
                        }
                    }
                    
                    // 排序完成
                    currentPhase.textContent = '排序完成';
                    currentStep.textContent = '完成';
                    stepInfo.textContent = 'Tim排序已完成！数组已完全排序。';
                    
                    // 显示排序完成动画
                    await showCompletionAnimation();
                    
                    isSorting = false;
                    startBtn.disabled = false;
                    startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    newArrayBtn.disabled = false;
                    newArrayBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    resetBtn.disabled = true;
                    resetBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    
                    if (isStepMode) {
                        stepBtn.disabled = true;
                        stepBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                }
                
                // 显示排序完成动画
                async function showCompletionAnimation() {
                    // 首先将所有元素标记为已排序
                    for (let i = 0; i < array.length; i++) {
                        barElements[i].classList.remove(ARRAY_COLOR);
                        barElements[i].classList.add(SORTED_COLOR);
                        await sleep(20);
                    }
                    
                    // 添加脉冲动画效果
                    for (let i = 0; i < array.length; i++) {
                        barElements[i].classList.add('animate-pulse');
                    }
                    
                    await sleep(500);
                    
                    // 显示成功消息
                    const successMessage = document.createElement('div');
                    successMessage.className = 'absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-500 flex items-center';
                    successMessage.innerHTML = '<i class="fas fa-check-circle mr-2 text-xl"></i>排序成功！';
                    successMessage.style.zIndex = '10';
                    
                    const container = document.getElementById('array-container');
                    container.style.position = 'relative';
                    container.appendChild(successMessage);
                    
                    // 显示消息
                    await sleep(100);
                    successMessage.classList.replace('opacity-0', 'opacity-100');
                    
                    // 等待一段时间后淡出
                    await sleep(2000);
                    successMessage.classList.replace('opacity-100', 'opacity-0');
                    
                    // 清除脉冲动画
                    await sleep(500);
                    for (let i = 0; i < array.length; i++) {
                        barElements[i].classList.remove('animate-pulse');
                    }
                    
                    // 移除消息
                    await sleep(500);
                    container.removeChild(successMessage);
                }
                
                // 找到需要合并的runs
                function findRunToMerge() {
                    if (runs.length <= 1) return -1;
                    
                    // 简化的合并策略：始终合并最短的相邻runs
                    let minIdx = 0;
                    let minSum = runs[0].length + runs[1].length;
                    
                    for (let i = 1; i < runs.length - 1; i++) {
                        const sum = runs[i].length + runs[i + 1].length;
                        if (sum < minSum) {
                            minSum = sum;
                            minIdx = i;
                        }
                    }
                    
                    return minIdx;
                }
                
                // 识别自然run
                function identifyRun(start) {
                    let i = start;
                    
                    // 如果只有一个元素，返回1
                    if (start >= array.length - 1) return 1;
                    
                    // 确定run是递增还是递减
                    let ascending = array[start] <= array[start + 1];
                    
                    // 向前查找
                    i++;
                    while (i < array.length - 1) {
                        comparisons++;
                        compareCount.textContent = comparisons;
                        
                        if (ascending && array[i] > array[i + 1]) break;
                        if (!ascending && array[i] < array[i + 1]) break;
                        i++;
                    }
                    
                    // 对于递减的run，将其反转为递增
                    if (!ascending) {
                        let left = start;
                        let right = i;
                        
                        stepInfo.textContent = `发现递减run，从 ${left} 到 ${right}，进行反转`;
                        renderArray(Array.from({length: right - left + 1}, (_, idx) => idx + left));
                        
                        while (left < right) {
                            swaps++;
                            swapCount.textContent = swaps;
                            
                            [array[left], array[right]] = [array[right], array[left]];
                            left++;
                            right--;
                        }
                    }
                    
                    return i - start + 1;
                }
                
                // 插入排序
                async function insertionSort(left, right) {
                    for (let i = left + 1; i <= right; i++) {
                        const temp = array[i];
                        let j = i - 1;
                        
                        stepInfo.textContent = `插入排序：插入元素 ${temp} (索引 ${i})`;
                        renderArray(null, [i]);
                        await handleAnimation();
                        
                        while (j >= left && array[j] > temp) {
                            comparisons++;
                            compareCount.textContent = comparisons;
                            
                            stepInfo.textContent = `比较: ${array[j]} > ${temp}，移动元素`;
                            renderArray(null, [j, j+1]);
                            await handleAnimation();
                            
                            array[j + 1] = array[j];
                            swaps++;
                            swapCount.textContent = swaps;
                            
                            j--;
                        }
                        
                        if (j + 1 !== i) {
                            array[j + 1] = temp;
                            stepInfo.textContent = `将 ${temp} 插入位置 ${j+1}`;
                            renderArray(null, [], j+1);
                            await handleAnimation();
                        }
                    }
                }
                
                // 合并两个相邻的runs
                async function mergeRuns(start, mid, end) {
                    const temp = array.slice(start, end + 1);
                    const leftSize = mid - start + 1;
                    
                    let i = 0; // 左半部分索引
                    let j = leftSize; // 右半部分索引
                    let k = start; // 原数组索引
                    
                    stepInfo.textContent = `开始合并: [${start}:${mid}] 和 [${mid+1}:${end}]`;
                    renderArray(Array.from({length: end - start + 1}, (_, idx) => idx + start));
                    await handleAnimation();
                    
                    while (i < leftSize && j < temp.length) {
                        comparisons++;
                        compareCount.textContent = comparisons;
                        
                        stepInfo.textContent = `比较: ${temp[i]} 和 ${temp[j]}`;
                        renderArray(null, [k, start + (j - leftSize) + leftSize]);
                        await handleAnimation();
                        
                        if (temp[i] <= temp[j]) {
                            array[k] = temp[i];
                            i++;
                        } else {
                            array[k] = temp[j];
                            j++;
                            swaps++;
                            swapCount.textContent = swaps;
                        }
                        
                        renderArray(null, [k]);
                        await handleAnimation();
                        
                        k++;
                    }
                    
                    // 复制剩余元素
                    while (i < leftSize) {
                        array[k] = temp[i];
                        renderArray(null, [k]);
                        await handleAnimation();
                        k++;
                        i++;
                    }
                    
                    while (j < temp.length) {
                        array[k] = temp[j];
                        renderArray(null, [k]);
                        await handleAnimation();
                        k++;
                        j++;
                    }
                    
                    stepInfo.textContent = `合并完成: [${start}:${end}]`;
                    renderArray(Array.from({length: end - start + 1}, (_, idx) => idx + start));
                    await handleAnimation();
                }
                
                // 处理动画
                async function handleAnimation() {
                    if (isStepMode) {
                        // 在步进模式下，等待用户点击
                        currentStep.textContent = '等待下一步...';
                        
                        // 启用步进按钮，让用户可以点击
                        stepBtn.disabled = false;
                        stepBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        
                        // 显示提示
                        stepInfo.textContent += ' (点击"单步执行"继续)';
                        
                        return new Promise(resolve => {
                            animationResolve = resolve;
                        });
                    } else {
                        // 正常模式，使用延迟
                        return sleep(getDelay());
                    }
                }
                
                // 开始排序
                async function startSorting() {
                    if (isSorting) return;
                    
                    isSorting = true;
                    isStepMode = false;
                    
                    // 更新按钮状态
                    startBtn.disabled = true;
                    startBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    
                    newArrayBtn.disabled = true;
                    newArrayBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    
                    resetBtn.disabled = false;
                    resetBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    stepBtn.disabled = true;
                    stepBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    
                    // 更新状态显示
                    currentPhase.textContent = '开始排序...';
                    
                    try {
                        await timSort();
                    } catch (error) {
                        console.error('Sorting error:', error);
                        isSorting = false;
                        
                        // 恢复按钮状态
                        resetSorting();
                    }
                }
                
                // 步进排序
                function stepSorting() {
                    if (!isSorting) {
                        // 首次启动步进模式
                        isSorting = true;
                        isStepMode = true;
                        
                        // 更新按钮状态
                        startBtn.disabled = true;
                        startBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        
                        newArrayBtn.disabled = true;
                        newArrayBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        
                        resetBtn.disabled = false;
                        resetBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        
                        // 更新状态显示
                        currentPhase.textContent = '步进模式...';
                        
                        timSort().catch(error => {
                            console.error('Sorting error:', error);
                            isSorting = false;
                            
                            // 恢复按钮状态
                            resetSorting();
                        });
                    } else if (isStepMode && animationResolve) {
                        // 执行下一步
                        stepBtn.disabled = true;
                        stepBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        
                        const resolve = animationResolve;
                        animationResolve = null;
                        resolve();
                    }
                }
                
                // 重置排序
                function resetSorting() {
                    // 清理定时器
                    if (sortingTimeout) {
                        clearTimeout(sortingTimeout);
                        sortingTimeout = null;
                    }
                    
                    // 重置数组和状态
                    array = [...originalArray];
                    runs = [];
                    animationResolve = null;
                    
                    isSorting = false;
                    isStepMode = false;
                    
                    // 重置UI按钮状态
                    startBtn.disabled = false;
                    startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    newArrayBtn.disabled = false;
                    newArrayBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    resetBtn.disabled = true;
                    resetBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    
                    stepBtn.disabled = false;
                    stepBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    // 重置状态显示
                    currentPhase.textContent = '等待开始';
                    currentStep.textContent = '-';
                    stepInfo.textContent = '准备开始Tim排序。点击"开始排序"按钮开始，或使用"单步执行"按钮逐步观察排序过程。';
                    
                    // 重置统计数据
                    resetStats();
                    
                    // 重新渲染数组
                    renderArray();
                }
                
                // 初始化
                function initialize() {
                    // 初始化按钮状态
                    resetBtn.disabled = true;
                    resetBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    
                    // 初始化数组
                    generateArray();
                    
                    // 设置速度显示
                    speedValue.textContent = speedMap[speedSlider.value].label;
                    
                    // 确保按钮状态正确
                    startBtn.disabled = false;
                    newArrayBtn.disabled = false;
                    stepBtn.disabled = false;
                    
                    // 初始化状态文本
                    currentPhase.textContent = '等待开始';
                    currentStep.textContent = '-';
                    stepInfo.textContent = '准备开始Tim排序。点击"开始排序"按钮开始，或使用"单步执行"按钮逐步观察排序过程。';
                    
                    // 添加按钮悬停效果
                    addButtonHoverEffects();
                }
                
                // 添加按钮悬停效果
                function addButtonHoverEffects() {
                    const buttons = [newArrayBtn, startBtn, stepBtn, resetBtn];
                    
                    buttons.forEach(button => {
                        if (!button.hasHoverListeners) {
                            button.addEventListener('mouseenter', function() {
                                if (!this.disabled) {
                                    this.classList.add('shadow-lg', 'transform', 'scale-105');
                                    this.style.transition = 'all 0.2s ease';
                                }
                            });
                            
                            button.addEventListener('mouseleave', function() {
                                this.classList.remove('shadow-lg', 'transform', 'scale-105');
                            });
                            
                            button.hasHoverListeners = true;
                        }
                    });
                }
                
                // 事件监听器
                newArrayBtn.addEventListener('click', generateArray);
                startBtn.addEventListener('click', startSorting);
                stepBtn.addEventListener('click', stepSorting);
                resetBtn.addEventListener('click', resetSorting);
                
                speedSlider.addEventListener('input', function() {
                    speedValue.textContent = speedMap[this.value].label;
                });
                
                // 初始化全局变量
                let animationResolve = null;
                
                // 执行初始化
                initialize();
            });
        </script>
    </div>
</body>
</html> 